Updating build index: /Users/runner/conda/conda-bld

TEST START: /var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T/tmpsbf8yy53/osx-64/scikit-bio-0.5.6-py39hbaf7cf3_4.tar.bz2
Reloading output folder: /Users/runner/conda/conda-bld

## Package Plan ##

  environment location: /Users/runner/conda/conda-bld/scikit-bio_1636069023083/_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol


The following NEW packages will be INSTALLED:

    appnope:                       0.1.2-py39h6e9494a_2     conda-forge                                                        
    attrs:                         21.2.0-pyhd8ed1ab_0      conda-forge                                                        
    backcall:                      0.2.0-pyh9f0ad1d_0       conda-forge                                                        
    backports:                     1.0-py_2                 conda-forge                                                        
    backports.functools_lru_cache: 1.6.4-pyhd8ed1ab_0       conda-forge                                                        
    brotlipy:                      0.7.0-py39h89e85a6_1003  conda-forge                                                        
    ca-certificates:               2021.10.8-h033912b_0     conda-forge                                                        
    cachecontrol:                  0.12.9-pyhd8ed1ab_0      conda-forge                                                        
    certifi:                       2021.10.8-py39h6e9494a_1 conda-forge                                                        
    cffi:                          1.15.0-py39he338e87_0    conda-forge                                                        
    chardet:                       4.0.0-py39h6e9494a_2     conda-forge                                                        
    charset-normalizer:            2.0.0-pyhd8ed1ab_0       conda-forge                                                        
    cryptography:                  35.0.0-py39h209aa08_2    conda-forge                                                        
    cycler:                        0.11.0-pyhd8ed1ab_0      conda-forge                                                        
    cython:                        0.29.24-py39h9fcab8e_1   conda-forge                                                        
    decorator:                     5.1.0-pyhd8ed1ab_0       conda-forge                                                        
    freetype:                      2.10.4-h4cff582_1        conda-forge                                                        
    hdmedians:                     0.14.2-py39hc89836e_0    conda-forge                                                        
    idna:                          3.1-pyhd3deb0d_0         conda-forge                                                        
    iniconfig:                     1.1.1-pyh9f0ad1d_0       conda-forge                                                        
    ipython:                       7.29.0-py39h71a6800_1    conda-forge                                                        
    jbig:                          2.1-h0d85af4_2003        conda-forge                                                        
    jedi:                          0.18.0-py39h6e9494a_3    conda-forge                                                        
    joblib:                        1.1.0-pyhd8ed1ab_0       conda-forge                                                        
    jpeg:                          9d-hbcb3906_0            conda-forge                                                        
    kiwisolver:                    1.3.2-py39hf018cea_1     conda-forge                                                        
    lcms2:                         2.12-h577c468_0          conda-forge                                                        
    lerc:                          3.0-he49afe7_0           conda-forge                                                        
    libblas:                       3.9.0-12_osx64_openblas  conda-forge                                                        
    libcblas:                      3.9.0-12_osx64_openblas  conda-forge                                                        
    libcxx:                        12.0.1-habf9029_0        conda-forge                                                        
    libdeflate:                    1.8-h0d85af4_0           conda-forge                                                        
    libffi:                        3.4.2-he49afe7_4         conda-forge                                                        
    libgfortran:                   5.0.0-9_3_0_h6c81a4c_23  conda-forge                                                        
    libgfortran5:                  9.3.0-h6c81a4c_23        conda-forge                                                        
    liblapack:                     3.9.0-12_osx64_openblas  conda-forge                                                        
    libopenblas:                   0.3.18-openmp_h3351f45_0 conda-forge                                                        
    libpng:                        1.6.37-h7cec526_2        conda-forge                                                        
    libtiff:                       4.3.0-hd146c10_2         conda-forge                                                        
    libwebp-base:                  1.2.1-h0d85af4_0         conda-forge                                                        
    libzlib:                       1.2.11-h9173be1_1013     conda-forge                                                        
    llvm-openmp:                   12.0.1-hda6cdc1_1        conda-forge                                                        
    lockfile:                      0.12.2-py_1              conda-forge                                                        
    lz4-c:                         1.9.3-he49afe7_1         conda-forge                                                        
    matplotlib-base:               3.4.3-py39hb07454d_1     conda-forge                                                        
    matplotlib-inline:             0.1.3-pyhd8ed1ab_0       conda-forge                                                        
    more-itertools:                8.10.0-pyhd8ed1ab_0      conda-forge                                                        
    msgpack-python:                1.0.2-py39hf018cea_2     conda-forge                                                        
    natsort:                       8.0.0-pyhd8ed1ab_0       conda-forge                                                        
    ncurses:                       6.2-h2e338ed_4           conda-forge                                                        
    numpy:                         1.21.3-py39h7eed0ac_1    conda-forge                                                        
    olefile:                       0.46-pyh9f0ad1d_1        conda-forge                                                        
    openjpeg:                      2.4.0-h6e7aa92_1         conda-forge                                                        
    openssl:                       1.1.1l-h0d85af4_0        conda-forge                                                        
    packaging:                     21.2-pyhd8ed1ab_1        conda-forge                                                        
    pandas:                        1.3.4-py39h4d6be9b_0     conda-forge                                                        
    parso:                         0.8.2-pyhd8ed1ab_0       conda-forge                                                        
    pexpect:                       4.8.0-pyh9f0ad1d_2       conda-forge                                                        
    pickleshare:                   0.7.5-py39hde42818_1002  conda-forge                                                        
    pillow:                        8.3.2-py39he9bb72f_0     conda-forge                                                        
    pip:                           21.3.1-pyhd8ed1ab_0      conda-forge                                                        
    pluggy:                        1.0.0-py39h6e9494a_2     conda-forge                                                        
    prompt-toolkit:                3.0.22-pyha770c72_0      conda-forge                                                        
    ptyprocess:                    0.7.0-pyhd3deb0d_0       conda-forge                                                        
    py:                            1.10.0-pyhd3deb0d_0      conda-forge                                                        
    pycparser:                     2.20-pyh9f0ad1d_2        conda-forge                                                        
    pygments:                      2.10.0-pyhd8ed1ab_0      conda-forge                                                        
    pyopenssl:                     21.0.0-pyhd8ed1ab_0      conda-forge                                                        
    pyparsing:                     2.4.7-pyhd8ed1ab_1       conda-forge                                                        
    pysocks:                       1.7.1-py39h6e9494a_4     conda-forge                                                        
    pytest:                        6.2.5-py39h6e9494a_1     conda-forge                                                        
    python:                        3.9.7-h1248fe1_3_cpython conda-forge                                                        
    python-dateutil:               2.8.2-pyhd8ed1ab_0       conda-forge                                                        
    python_abi:                    3.9-2_cp39               conda-forge                                                        
    pytz:                          2021.3-pyhd8ed1ab_0      conda-forge                                                        
    readline:                      8.1-h05e3726_0           conda-forge                                                        
    requests:                      2.26.0-pyhd8ed1ab_0      conda-forge                                                        
    scikit-bio:                    0.5.6-py39hbaf7cf3_4     file:///var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T/tmpsbf8yy53
    scikit-learn:                  1.0.1-py39hd2caeff_1     conda-forge                                                        
    scipy:                         1.7.1-py39h056f1c0_0     conda-forge                                                        
    setuptools:                    58.5.2-py39h6e9494a_0    conda-forge                                                        
    six:                           1.16.0-pyh6c4a22f_0      conda-forge                                                        
    sqlite:                        3.36.0-h23a322b_2        conda-forge                                                        
    threadpoolctl:                 3.0.0-pyh8a188c0_0       conda-forge                                                        
    tk:                            8.6.11-h5dbffcc_1        conda-forge                                                        
    toml:                          0.10.2-pyhd8ed1ab_0      conda-forge                                                        
    tornado:                       6.1-py39h89e85a6_2       conda-forge                                                        
    traitlets:                     5.1.1-pyhd8ed1ab_0       conda-forge                                                        
    tzdata:                        2021e-he74cb21_0         conda-forge                                                        
    urllib3:                       1.26.7-pyhd8ed1ab_0      conda-forge                                                        
    wcwidth:                       0.2.5-pyh9f0ad1d_2       conda-forge                                                        
    wheel:                         0.37.0-pyhd8ed1ab_1      conda-forge                                                        
    xz:                            5.2.5-haf1e3a3_1         conda-forge                                                        
    zlib:                          1.2.11-h9173be1_1013     conda-forge                                                        
    zstd:                          1.5.0-h582d3a0_0         conda-forge                                                        

Preparing transaction: ...working... done
Verifying transaction: ...working... done
Executing transaction: ...working... done
export PREFIX=/Users/runner/conda/conda-bld/scikit-bio_1636069023083/_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol
export SRC_DIR=/Users/runner/conda/conda-bld/scikit-bio_1636069023083/test_tmp
import: 'skbio'
import: 'skbio.alignment'
import: 'skbio.alignment._lib'
import: 'skbio.alignment.tests'
import: 'skbio.diversity'
import: 'skbio.diversity.alpha'
import: 'skbio.diversity.alpha.tests'
import: 'skbio.diversity.beta'
import: 'skbio.diversity.beta.tests'
import: 'skbio.diversity.tests'
import: 'skbio.io'
import: 'skbio.io.format'
import: 'skbio.io.format.tests'
import: 'skbio.io.tests'
import: 'skbio.sequence'
import: 'skbio.sequence.tests'
import: 'skbio.stats'
import: 'skbio.stats.distance'
import: 'skbio.stats.distance.tests'
import: 'skbio.stats.evolve'
import: 'skbio.stats.evolve.tests'
import: 'skbio.stats.ordination'
import: 'skbio.stats.ordination.tests'
import: 'skbio.stats.tests'
import: 'skbio.tests'
import: 'skbio.tree'
import: 'skbio.tree.tests'
import: 'skbio.util'
import: 'skbio.util.tests'
import: 'skbio'
import: 'skbio.alignment'
import: 'skbio.alignment._lib'
import: 'skbio.alignment.tests'
import: 'skbio.diversity'
import: 'skbio.diversity.alpha'
import: 'skbio.diversity.alpha.tests'
import: 'skbio.diversity.beta'
import: 'skbio.diversity.beta.tests'
import: 'skbio.diversity.tests'
import: 'skbio.io'
import: 'skbio.io.format'
import: 'skbio.io.format.tests'
import: 'skbio.io.tests'
import: 'skbio.sequence'
import: 'skbio.sequence.tests'
import: 'skbio.stats'
import: 'skbio.stats.distance'
import: 'skbio.stats.distance.tests'
import: 'skbio.stats.evolve'
import: 'skbio.stats.evolve.tests'
import: 'skbio.stats.ordination'
import: 'skbio.stats.ordination.tests'
import: 'skbio.stats.tests'
import: 'skbio.tests'
import: 'skbio.tree'
import: 'skbio.tree.tests'
import: 'skbio.util'
import: 'skbio.util.tests'
============================= test session starts ==============================
platform darwin -- Python 3.9.7, pytest-6.2.5, py-1.10.0, pluggy-1.0.0
rootdir: $SRC_DIR
collected 2574 items

workflow.py .                                                            [  0%]
alignment/__init__.py .                                                  [  0%]
alignment/_tabular_msa.py ........................                       [  1%]
alignment/tests/test_pairwise.py .........................               [  1%]
alignment/tests/test_ssw.py ...........................                  [  3%]
alignment/tests/test_tabular_msa.py .................................... [  4%]
........................................................................ [  7%]
........................................................................ [ 10%]
...F.................................................................... [ 12%]
........................................................................ [ 15%]
........................................................................ [ 18%]
.......                                                                  [ 18%]
diversity/__init__.py .                                                  [ 18%]
diversity/alpha/_faith_pd.py .                                           [ 18%]
diversity/alpha/tests/test_ace.py ..                                     [ 18%]
diversity/alpha/tests/test_base.py ........................              [ 19%]
diversity/alpha/tests/test_chao1.py ...                                  [ 19%]
diversity/alpha/tests/test_faith_pd.py ........                          [ 20%]
diversity/alpha/tests/test_gini.py ...                                   [ 20%]
diversity/alpha/tests/test_lladser.py ............                       [ 20%]
diversity/beta/_unifrac.py ..                                            [ 20%]
diversity/beta/tests/test_unifrac.py ............................        [ 21%]
diversity/tests/test_block.py ...........                                [ 22%]
diversity/tests/test_driver.py ..................................        [ 23%]
diversity/tests/test_util.py ..........                                  [ 24%]
io/__init__.py .                                                         [ 24%]
io/registry.py ...                                                       [ 24%]
io/util.py .                                                             [ 24%]
io/format/blast6.py .                                                    [ 24%]
io/format/blast7.py .                                                    [ 24%]
io/format/clustal.py .                                                   [ 24%]
io/format/embl.py .                                                      [ 24%]
io/format/fasta.py .                                                     [ 24%]
io/format/fastq.py .                                                     [ 24%]
io/format/genbank.py .                                                   [ 24%]
io/format/gff3.py .                                                      [ 24%]
io/format/newick.py .                                                    [ 24%]
io/format/ordination.py .                                                [ 24%]
io/format/phylip.py .                                                    [ 24%]
io/format/qseq.py .                                                      [ 24%]
io/format/stockholm.py .                                                 [ 24%]
io/format/tests/test_base.py ................................            [ 26%]
io/format/tests/test_blast6.py ...........                               [ 26%]
io/format/tests/test_blast7.py ..............                            [ 27%]
io/format/tests/test_clustal.py .............                            [ 27%]
io/format/tests/test_embl.py ...............................             [ 28%]
io/format/tests/test_emptyfile.py ..                                     [ 28%]
io/format/tests/test_fasta.py ................                           [ 29%]
io/format/tests/test_fastq.py ...............                            [ 29%]
io/format/tests/test_genbank.py .....................                    [ 30%]
io/format/tests/test_gff3.py ........................                    [ 31%]
io/format/tests/test_lsmat.py .......                                    [ 32%]
io/format/tests/test_newick.py .......                                   [ 32%]
io/format/tests/test_ordination.py .....                                 [ 32%]
io/format/tests/test_phylip.py .......                                   [ 32%]
io/format/tests/test_qseq.py ......                                      [ 32%]
io/format/tests/test_sequence_feature_vocabulary.py ....                 [ 33%]
io/format/tests/test_stockholm.py ...................................... [ 34%]
.....................................                                    [ 36%]
io/tests/test_iosources.py ..........                                    [ 36%]
io/tests/test_registry.py .............................................. [ 38%]
................................................                         [ 40%]
io/tests/test_util.py .........................................sssssssss [ 42%]
sssssssssssssssssssss................................................... [ 44%]
........................................................................ [ 47%]
..........................                                               [ 48%]
metadata/_interval.py ...                                                [ 48%]
metadata/_mixin.py ....                                                  [ 48%]
metadata/tests/test_intersection.py ...............                      [ 49%]
metadata/tests/test_interval.py ........................................ [ 51%]
...............................                                          [ 52%]
metadata/tests/test_mixin.py ........................................... [ 53%]
.......................................................                  [ 56%]
sequence/__init__.py .                                                   [ 56%]
sequence/_dna.py ....                                                    [ 56%]
sequence/_genetic_code.py .....                                          [ 56%]
sequence/_grammared_sequence.py .............                            [ 56%]
sequence/_nucleotide_mixin.py .....                                      [ 57%]
sequence/_protein.py ...                                                 [ 57%]
sequence/_rna.py ....                                                    [ 57%]
sequence/_sequence.py .............................                      [ 58%]
sequence/distance.py ..                                                  [ 58%]
sequence/tests/test_distance.py ..........................               [ 59%]
sequence/tests/test_dna.py ....                                          [ 59%]
sequence/tests/test_genetic_code.py ..........................           [ 60%]
sequence/tests/test_grammared_sequence.py .............................. [ 61%]
.............                                                            [ 62%]
sequence/tests/test_nucleotide_sequences.py ............................ [ 63%]
.                                                                        [ 63%]
sequence/tests/test_protein.py ..........                                [ 63%]
sequence/tests/test_rna.py ....                                          [ 64%]
sequence/tests/test_sequence.py ........................................ [ 65%]
........................................................................ [ 68%]
........................................................................ [ 71%]
........................................................................ [ 74%]
..                                                                       [ 74%]
stats/_subsample.py ..                                                   [ 74%]
stats/composition.py ................                                    [ 74%]
stats/gradient.py .                                                      [ 74%]
stats/power.py ....                                                      [ 75%]
stats/distance/__init__.py .                                             [ 75%]
stats/distance/_anosim.py .                                              [ 75%]
stats/distance/_base.py .....                                            [ 75%]
stats/distance/_bioenv.py .                                              [ 75%]
stats/distance/_mantel.py ..                                             [ 75%]
stats/distance/_permdisp.py F                                            [ 75%]
stats/distance/tests/test_anosim.py ....                                 [ 75%]
stats/distance/tests/test_base.py ...................................... [ 77%]
.........................................................                [ 79%]
stats/distance/tests/test_bioenv.py .............F...                    [ 79%]
stats/distance/tests/test_mantel.py .................................... [ 81%]
...                                                                      [ 81%]
stats/distance/tests/test_permanova.py ....                              [ 81%]
stats/distance/tests/test_permdisp.py .FFFF.......                       [ 82%]
stats/evolve/_hommola.py .                                               [ 82%]
stats/evolve/tests/test_hommola.py ............                          [ 82%]
stats/ordination/__init__.py .                                           [ 82%]
stats/ordination/_ordination_results.py .                                [ 82%]
stats/ordination/tests/test_canonical_correspondence_analysis.py ......  [ 82%]
stats/ordination/tests/test_correspondence_analysis.py ........          [ 83%]
stats/ordination/tests/test_ordination_results.py ................       [ 83%]
stats/ordination/tests/test_principal_coordinate_analysis.py ........... [ 84%]
                                                                         [ 84%]
stats/ordination/tests/test_redundancy_analysis.py ....                  [ 84%]
stats/ordination/tests/test_util.py .........                            [ 84%]
stats/tests/test_composition.py ........................................ [ 86%]
..................                                                       [ 87%]
stats/tests/test_gradient.py .F........................                  [ 88%]
stats/tests/test_misc.py ...                                             [ 88%]
stats/tests/test_power.py ...........................................    [ 89%]
stats/tests/test_subsample.py ............                               [ 90%]
tests/test_base.py .....                                                 [ 90%]
tests/test_workflow.py .................                                 [ 91%]
tree/__init__.py .                                                       [ 91%]
tree/_majority_rule.py .                                                 [ 91%]
tree/_nj.py .                                                            [ 91%]
tree/_tree.py ......................................................     [ 93%]
tree/tests/test_majority_rule.py ......                                  [ 93%]
tree/tests/test_nj.py ...........                                        [ 94%]
tree/tests/test_tree.py ................................................ [ 95%]
...........................................                              [ 97%]
util/_decorator.py ...                                                   [ 97%]
util/_misc.py ..                                                         [ 97%]
util/tests/test_decorator.py .......................                     [ 98%]
util/tests/test_misc.py ...................                              [ 99%]
util/tests/test_testing.py ...............                               [100%]

=================================== FAILURES ===================================
___________ TestLoc.test_multiindex_complicated_axis_empty_selection ___________

self = <skbio.alignment.tests.test_tabular_msa.TestLoc testMethod=test_multiindex_complicated_axis_empty_selection>

    def test_multiindex_complicated_axis_empty_selection(self):
        a = RNA("UUAG", metadata={0: 0}, positional_metadata={0: [1, 2, 3, 4]})
        b = RNA("UAAG", metadata={1: 0}, positional_metadata={1: [1, 2, 3, 4]})
        c = RNA("UAA-", metadata={2: 0}, positional_metadata={2: [1, 2, 3, 4]})
        d = RNA("UA-G", metadata={3: 0}, positional_metadata={3: [1, 2, 3, 4]})
        msa = TabularMSA([a, b, c, d], metadata={'x': 'y'},
                         positional_metadata={'c': ['a', 'b', 'c', 'd']},
                         index=[('a', 'x', 0), ('a', 'x', 1), ('a', 'y', 2),
                                ('b', 'x', 0)])
    
>       self.assertEqual(self.get(msa, (([False, True, False, True],
                                         'x', 2), Ellipsis)),
                         TabularMSA([], metadata={'x': 'y'},
                                    # TODO: Change for #1198
                                    positional_metadata=None,
                                    index=[]))

../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/alignment/tests/test_tabular_msa.py:1390: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/alignment/tests/test_tabular_msa.py:1271: in get
    return obj.loc[indexable]
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/alignment/_indexing.py:39: in __getitem__
    return self._handle_both_axes(*indexable)
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/alignment/_indexing.py:53: in _handle_both_axes
    r = self._slice_on_first_axis(self._obj, seq_index)
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/alignment/_indexing.py:77: in _slice_on_first_axis
    return self._slice_sequences(obj, indexable)
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/alignment/_indexing.py:203: in _slice_sequences
    return obj._slice_sequences_loc_(indexable)
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/alignment/_tabular_msa.py:1192: in _slice_sequences_loc_
    new_seqs = self._seqs.loc[l]
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/pandas/core/indexing.py:925: in __getitem__
    return self._getitem_tuple(key)
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/pandas/core/indexing.py:1100: in _getitem_tuple
    return self._getitem_lowerdim(tup)
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/pandas/core/indexing.py:822: in _getitem_lowerdim
    return self._getitem_nested_tuple(tup)
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/pandas/core/indexing.py:892: in _getitem_nested_tuple
    return self._getitem_axis(tup, axis=axis)
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/pandas/core/indexing.py:1157: in _getitem_axis
    locs = labels.get_locs(key)
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/pandas/core/indexes/multi.py:3347: in get_locs
    indexer = _update_indexer(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

idxr = Int64Index([2], dtype='int64')
indexer = Int64Index([1, 3], dtype='int64')
key = ([False, True, False, True], 'x', 2)

    def _update_indexer(idxr: Index | None, indexer: Index | None, key) -> Index:
        if indexer is None:
            indexer = Index(np.arange(n))
        if idxr is None:
            return indexer
        indexer_intersection = indexer.intersection(idxr)
        if indexer_intersection.empty and not idxr.empty and not indexer.empty:
>           raise KeyError(key)
E           KeyError: ([False, True, False, True], 'x', 2)

../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/pandas/core/indexes/multi.py:3296: KeyError
______________ [doctest] skbio.stats.distance._permdisp.permdisp _______________
130     ...                       ['s1', 's2', 's3', 's4', 's5', 's6'])
131     >>> grouping = ['G1', 'G1', 'G1', 'G2', 'G2', 'G2']
132 
133     Run PERMDISP using 99 permutations to caluculate the p-value:
134 
135     >>> from skbio.stats.distance import permdisp
136     >>> import numpy as np
137     >>> #make output deterministic, should not be included during normal use
138     >>> np.random.seed(0)
139     >>> permdisp(dm, grouping, permutations=99)
Differences (unified diff with -expected +actual):
    @@ -3,6 +3,6 @@
     sample size                      6
     number of groups                 2
    -test statistic             1.03296
    -p-value                       ...
    +test statistic            1.032958
    +p-value                       0.35
     number of permutations          99
     Name: PERMDISP results, dtype: object

$PREFIX/lib/python3.9/site-packages/skbio/stats/distance/_permdisp.py:139: DocTestFailure
____________________ BIOENVTests.test_bioenv_vegan_example _____________________

self = <skbio.stats.distance.tests.test_bioenv.BIOENVTests testMethod=test_bioenv_vegan_example>

    def test_bioenv_vegan_example(self):
        # The correlation coefficient in the first row of the
        # results (rho=0.2516) is different from the correlation coefficient
        # computed by vegan (rho=0.2513). This seems to occur due to
        # differences in numerical precision when calculating the Euclidean
        # distances, which affects the rank calculations in Spearman
        # (specifically, dealing with ties). The ranked distances end up being
        # slightly different between vegan and our implementation because some
        # distances are treated as ties in vegan but treated as distinct values
        # in our implementation. This explains the difference in rho values. I
        # verified that using Pearson correlation instead of Spearman on the
        # same distances yields *very* similar results. Thus, the discrepancy
        # seems to stem from differences when computing ranks/ties.
        obs = bioenv(self.dm_vegan, self.df_vegan)
>       assert_data_frame_almost_equal(obs, self.exp_results_vegan)

../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/stats/distance/tests/test_bioenv.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/util/_testing.py:285: in assert_data_frame_almost_equal
    pdt.assert_frame_equal(left, right,
pandas/_libs/testing.pyx:53: in pandas._libs.testing.assert_almost_equal
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   AssertionError: DataFrame.iloc[:, 1] (column name="correlation") are different
E   
E   DataFrame.iloc[:, 1] (column name="correlation") values are different (16.66667 %)
E   [index]: [P, P, Al, P, Ca, Al, P, Ca, pH, Al, log(N), P, Ca, pH, Al, log(N), P, K, Ca, pH, Al]
E   [left]:  [0.251490209723, 0.40037784849, 0.40048058675, 0.361874973245, 0.321552489262, 0.282181475721]
E   [right]: [0.251630226096, 0.40037784849, 0.40048058675, 0.361874973245, 0.321552489262, 0.282181475721]

pandas/_libs/testing.pyx:168: AssertionError
____________________ testPERMDISP.test_centroids_eq_groups _____________________

self = <skbio.stats.distance.tests.test_permdisp.testPERMDISP testMethod=test_centroids_eq_groups>

    def test_centroids_eq_groups(self):
        exp = [[1.2886811963240687, 1.890538910062923, 1.490527658097728],
               [2.17349240061718, 2.3192679626679946, 2.028338553903792]]
        exp_stat, _ = f_oneway(*exp)
    
        dm = pcoa(self.eq_mat)
        dm = dm.samples
    
>       obs = _compute_groups(dm, 'centroid', self.grouping_eq)

../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/stats/distance/tests/test_permdisp.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/stats/distance/_permdisp.py:251: in _compute_groups
    groups.append(cdist(df.values[:, :-1], [centroids.loc[label].values],
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

XA = array([[-1.72493421729429, 0.4245950661770303, -0.4421150498378113,
        -0.8800986337268083, 0.0, 0.0],
       [-0...     [-1.813911896152713, 0.2501246313543305, 0.4241563824665491,
        0.9643046100830305, 0.0, 0.0]], dtype=object)
XB = array([[-1.19938106, -0.22670737, -0.50629061,  0.0977458 ,  0.        ,
         0.        ]])
metric = 'euclidean', out = None, kwargs = {}, s = (3, 6), sB = (1, 6), mA = 3
mB = 1, n = 6, mstr = 'euclidean'

    def cdist(XA, XB, metric='euclidean', *, out=None, **kwargs):
        """
        Compute distance between each pair of the two collections of inputs.
    
        See Notes for common calling conventions.
    
        Parameters
        ----------
        XA : array_like
            An :math:`m_A` by :math:`n` array of :math:`m_A`
            original observations in an :math:`n`-dimensional space.
            Inputs are converted to float type.
        XB : array_like
            An :math:`m_B` by :math:`n` array of :math:`m_B`
            original observations in an :math:`n`-dimensional space.
            Inputs are converted to float type.
        metric : str or callable, optional
            The distance metric to use. If a string, the distance function can be
            'braycurtis', 'canberra', 'chebyshev', 'cityblock', 'correlation',
            'cosine', 'dice', 'euclidean', 'hamming', 'jaccard', 'jensenshannon',
            'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto',
            'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath',
            'sqeuclidean', 'wminkowski', 'yule'.
        **kwargs : dict, optional
            Extra arguments to `metric`: refer to each metric documentation for a
            list of all possible arguments.
    
            Some possible arguments:
    
            p : scalar
            The p-norm to apply for Minkowski, weighted and unweighted.
            Default: 2.
    
            w : array_like
            The weight vector for metrics that support weights (e.g., Minkowski).
    
            V : array_like
            The variance vector for standardized Euclidean.
            Default: var(vstack([XA, XB]), axis=0, ddof=1)
    
            VI : array_like
            The inverse of the covariance matrix for Mahalanobis.
            Default: inv(cov(vstack([XA, XB].T))).T
    
            out : ndarray
            The output array
            If not None, the distance matrix Y is stored in this array.
    
        Returns
        -------
        Y : ndarray
            A :math:`m_A` by :math:`m_B` distance matrix is returned.
            For each :math:`i` and :math:`j`, the metric
            ``dist(u=XA[i], v=XB[j])`` is computed and stored in the
            :math:`ij` th entry.
    
        Raises
        ------
        ValueError
            An exception is thrown if `XA` and `XB` do not have
            the same number of columns.
    
        Notes
        -----
        The following are common calling conventions:
    
        1. ``Y = cdist(XA, XB, 'euclidean')``
    
           Computes the distance between :math:`m` points using
           Euclidean distance (2-norm) as the distance metric between the
           points. The points are arranged as :math:`m`
           :math:`n`-dimensional row vectors in the matrix X.
    
        2. ``Y = cdist(XA, XB, 'minkowski', p=2.)``
    
           Computes the distances using the Minkowski distance
           :math:`||u-v||_p` (:math:`p`-norm) where :math:`p \\geq 1`.
    
        3. ``Y = cdist(XA, XB, 'cityblock')``
    
           Computes the city block or Manhattan distance between the
           points.
    
        4. ``Y = cdist(XA, XB, 'seuclidean', V=None)``
    
           Computes the standardized Euclidean distance. The standardized
           Euclidean distance between two n-vectors ``u`` and ``v`` is
    
           .. math::
    
              \\sqrt{\\sum {(u_i-v_i)^2 / V[x_i]}}.
    
           V is the variance vector; V[i] is the variance computed over all
           the i'th components of the points. If not passed, it is
           automatically computed.
    
        5. ``Y = cdist(XA, XB, 'sqeuclidean')``
    
           Computes the squared Euclidean distance :math:`||u-v||_2^2` between
           the vectors.
    
        6. ``Y = cdist(XA, XB, 'cosine')``
    
           Computes the cosine distance between vectors u and v,
    
           .. math::
    
              1 - \\frac{u \\cdot v}
                       {{||u||}_2 {||v||}_2}
    
           where :math:`||*||_2` is the 2-norm of its argument ``*``, and
           :math:`u \\cdot v` is the dot product of :math:`u` and :math:`v`.
    
        7. ``Y = cdist(XA, XB, 'correlation')``
    
           Computes the correlation distance between vectors u and v. This is
    
           .. math::
    
              1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}
                       {{||(u - \\bar{u})||}_2 {||(v - \\bar{v})||}_2}
    
           where :math:`\\bar{v}` is the mean of the elements of vector v,
           and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.
    
    
        8. ``Y = cdist(XA, XB, 'hamming')``
    
           Computes the normalized Hamming distance, or the proportion of
           those vector elements between two n-vectors ``u`` and ``v``
           which disagree. To save memory, the matrix ``X`` can be of type
           boolean.
    
        9. ``Y = cdist(XA, XB, 'jaccard')``
    
           Computes the Jaccard distance between the points. Given two
           vectors, ``u`` and ``v``, the Jaccard distance is the
           proportion of those elements ``u[i]`` and ``v[i]`` that
           disagree where at least one of them is non-zero.
    
        10. ``Y = cdist(XA, XB, 'jensenshannon')``
    
            Computes the Jensen-Shannon distance between two probability arrays.
            Given two probability vectors, :math:`p` and :math:`q`, the
            Jensen-Shannon distance is
    
            .. math::
    
               \\sqrt{\\frac{D(p \\parallel m) + D(q \\parallel m)}{2}}
    
            where :math:`m` is the pointwise mean of :math:`p` and :math:`q`
            and :math:`D` is the Kullback-Leibler divergence.
    
        11. ``Y = cdist(XA, XB, 'chebyshev')``
    
            Computes the Chebyshev distance between the points. The
            Chebyshev distance between two n-vectors ``u`` and ``v`` is the
            maximum norm-1 distance between their respective elements. More
            precisely, the distance is given by
    
            .. math::
    
               d(u,v) = \\max_i {|u_i-v_i|}.
    
        12. ``Y = cdist(XA, XB, 'canberra')``
    
            Computes the Canberra distance between the points. The
            Canberra distance between two points ``u`` and ``v`` is
    
            .. math::
    
              d(u,v) = \\sum_i \\frac{|u_i-v_i|}
                                   {|u_i|+|v_i|}.
    
        13. ``Y = cdist(XA, XB, 'braycurtis')``
    
            Computes the Bray-Curtis distance between the points. The
            Bray-Curtis distance between two points ``u`` and ``v`` is
    
    
            .. math::
    
                 d(u,v) = \\frac{\\sum_i (|u_i-v_i|)}
                               {\\sum_i (|u_i+v_i|)}
    
        14. ``Y = cdist(XA, XB, 'mahalanobis', VI=None)``
    
            Computes the Mahalanobis distance between the points. The
            Mahalanobis distance between two points ``u`` and ``v`` is
            :math:`\\sqrt{(u-v)(1/V)(u-v)^T}` where :math:`(1/V)` (the ``VI``
            variable) is the inverse covariance. If ``VI`` is not None,
            ``VI`` will be used as the inverse covariance matrix.
    
        15. ``Y = cdist(XA, XB, 'yule')``
    
            Computes the Yule distance between the boolean
            vectors. (see `yule` function documentation)
    
        16. ``Y = cdist(XA, XB, 'matching')``
    
            Synonym for 'hamming'.
    
        17. ``Y = cdist(XA, XB, 'dice')``
    
            Computes the Dice distance between the boolean vectors. (see
            `dice` function documentation)
    
        18. ``Y = cdist(XA, XB, 'kulsinski')``
    
            Computes the Kulsinski distance between the boolean
            vectors. (see `kulsinski` function documentation)
    
        19. ``Y = cdist(XA, XB, 'rogerstanimoto')``
    
            Computes the Rogers-Tanimoto distance between the boolean
            vectors. (see `rogerstanimoto` function documentation)
    
        20. ``Y = cdist(XA, XB, 'russellrao')``
    
            Computes the Russell-Rao distance between the boolean
            vectors. (see `russellrao` function documentation)
    
        21. ``Y = cdist(XA, XB, 'sokalmichener')``
    
            Computes the Sokal-Michener distance between the boolean
            vectors. (see `sokalmichener` function documentation)
    
        22. ``Y = cdist(XA, XB, 'sokalsneath')``
    
            Computes the Sokal-Sneath distance between the vectors. (see
            `sokalsneath` function documentation)
    
    
        23. ``Y = cdist(XA, XB, 'wminkowski', p=2., w=w)``
    
            Computes the weighted Minkowski distance between the
            vectors. (see `wminkowski` function documentation)
    
            'wminkowski' is deprecated and will be removed in SciPy 1.8.0.
            Use 'minkowski' instead.
    
        24. ``Y = cdist(XA, XB, f)``
    
            Computes the distance between all pairs of vectors in X
            using the user supplied 2-arity function f. For example,
            Euclidean distance between the vectors could be computed
            as follows::
    
              dm = cdist(XA, XB, lambda u, v: np.sqrt(((u-v)**2).sum()))
    
            Note that you should avoid passing a reference to one of
            the distance functions defined in this library. For example,::
    
              dm = cdist(XA, XB, sokalsneath)
    
            would calculate the pair-wise distances between the vectors in
            X using the Python function `sokalsneath`. This would result in
            sokalsneath being called :math:`{n \\choose 2}` times, which
            is inefficient. Instead, the optimized C version is more
            efficient, and we call it using the following syntax::
    
              dm = cdist(XA, XB, 'sokalsneath')
    
        Examples
        --------
        Find the Euclidean distances between four 2-D coordinates:
    
        >>> from scipy.spatial import distance
        >>> coords = [(35.0456, -85.2672),
        ...           (35.1174, -89.9711),
        ...           (35.9728, -83.9422),
        ...           (36.1667, -86.7833)]
        >>> distance.cdist(coords, coords, 'euclidean')
        array([[ 0.    ,  4.7044,  1.6172,  1.8856],
               [ 4.7044,  0.    ,  6.0893,  3.3561],
               [ 1.6172,  6.0893,  0.    ,  2.8477],
               [ 1.8856,  3.3561,  2.8477,  0.    ]])
    
    
        Find the Manhattan distance from a 3-D point to the corners of the unit
        cube:
    
        >>> a = np.array([[0, 0, 0],
        ...               [0, 0, 1],
        ...               [0, 1, 0],
        ...               [0, 1, 1],
        ...               [1, 0, 0],
        ...               [1, 0, 1],
        ...               [1, 1, 0],
        ...               [1, 1, 1]])
        >>> b = np.array([[ 0.1,  0.2,  0.4]])
        >>> distance.cdist(a, b, 'cityblock')
        array([[ 0.7],
               [ 0.9],
               [ 1.3],
               [ 1.5],
               [ 1.5],
               [ 1.7],
               [ 2.1],
               [ 2.3]])
    
        """
        # You can also call this as:
        #     Y = cdist(XA, XB, 'test_abc')
        # where 'abc' is the metric being tested.  This computes the distance
        # between all pairs of vectors in XA and XB using the distance metric 'abc'
        # but with a more succinct, verifiable, but less efficient implementation.
    
        XA = np.asarray(XA)
        XB = np.asarray(XB)
    
        s = XA.shape
        sB = XB.shape
    
        if len(s) != 2:
            raise ValueError('XA must be a 2-dimensional array.')
        if len(sB) != 2:
            raise ValueError('XB must be a 2-dimensional array.')
        if s[1] != sB[1]:
            raise ValueError('XA and XB must have the same number of columns '
                             '(i.e. feature dimension.)')
    
        mA = s[0]
        mB = sB[0]
        n = s[1]
    
        if callable(metric):
            mstr = getattr(metric, '__name__', 'Unknown')
            metric_info = _METRIC_ALIAS.get(mstr, None)
            if metric_info is not None:
                XA, XB, typ, kwargs = _validate_cdist_input(
                    XA, XB, mA, mB, n, metric_info, **kwargs)
            return _cdist_callable(XA, XB, metric=metric, out=out, **kwargs)
        elif isinstance(metric, str):
            mstr = metric.lower()
            metric_info = _METRIC_ALIAS.get(mstr, None)
            if metric_info is not None:
                cdist_fn = metric_info.cdist_func
>               return cdist_fn(XA, XB, out=out, **kwargs)
E               ValueError: Unsupported dtype object

../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/scipy/spatial/distance.py:2954: ValueError
___________________ testPERMDISP.test_centroids_mixedgroups ____________________

self = <skbio.stats.distance.tests.test_permdisp.testPERMDISP testMethod=test_centroids_mixedgroups>

    def test_centroids_mixedgroups(self):
        exp = [[2.5847022428144935, 2.285624595858895,
                1.7022431146340287],
               [1.724817266046108, 1.724817266046108],
               [2.4333280644972795, 2.389000390879655,
                2.8547180589306036, 3.218568759338847]]
        dm = pcoa(self.uneq_mat)
        dm = dm.samples
    
        exp_stat, _ = f_oneway(*exp)
    
>       obs_mixed = _compute_groups(dm, 'centroid', self.grouping_un_mixed)

../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/stats/distance/tests/test_permdisp.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/stats/distance/_permdisp.py:251: in _compute_groups
    groups.append(cdist(df.values[:, :-1], [centroids.loc[label].values],
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

XA = array([[1.0559100095568086, 1.5297925821761884, 1.5885925999277586,
        -0.27423308995024553, -0.9980655246587443,...5152868578, -1.8614901635882684,
        0.018065319797415245, 0.18781865676804546, 0.0, 0.0, 0.0, 0.0]], dtype=object)
XB = array([[ 0.96679999,  0.24357552, -0.42381734,  0.41217343, -0.29276908,
         0.        ,  0.        ,  0.        ,  0.        ]])
metric = 'euclidean', out = None, kwargs = {}, s = (3, 9), sB = (1, 9), mA = 3
mB = 1, n = 9, mstr = 'euclidean'

    def cdist(XA, XB, metric='euclidean', *, out=None, **kwargs):
        """
        Compute distance between each pair of the two collections of inputs.
    
        See Notes for common calling conventions.
    
        Parameters
        ----------
        XA : array_like
            An :math:`m_A` by :math:`n` array of :math:`m_A`
            original observations in an :math:`n`-dimensional space.
            Inputs are converted to float type.
        XB : array_like
            An :math:`m_B` by :math:`n` array of :math:`m_B`
            original observations in an :math:`n`-dimensional space.
            Inputs are converted to float type.
        metric : str or callable, optional
            The distance metric to use. If a string, the distance function can be
            'braycurtis', 'canberra', 'chebyshev', 'cityblock', 'correlation',
            'cosine', 'dice', 'euclidean', 'hamming', 'jaccard', 'jensenshannon',
            'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto',
            'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath',
            'sqeuclidean', 'wminkowski', 'yule'.
        **kwargs : dict, optional
            Extra arguments to `metric`: refer to each metric documentation for a
            list of all possible arguments.
    
            Some possible arguments:
    
            p : scalar
            The p-norm to apply for Minkowski, weighted and unweighted.
            Default: 2.
    
            w : array_like
            The weight vector for metrics that support weights (e.g., Minkowski).
    
            V : array_like
            The variance vector for standardized Euclidean.
            Default: var(vstack([XA, XB]), axis=0, ddof=1)
    
            VI : array_like
            The inverse of the covariance matrix for Mahalanobis.
            Default: inv(cov(vstack([XA, XB].T))).T
    
            out : ndarray
            The output array
            If not None, the distance matrix Y is stored in this array.
    
        Returns
        -------
        Y : ndarray
            A :math:`m_A` by :math:`m_B` distance matrix is returned.
            For each :math:`i` and :math:`j`, the metric
            ``dist(u=XA[i], v=XB[j])`` is computed and stored in the
            :math:`ij` th entry.
    
        Raises
        ------
        ValueError
            An exception is thrown if `XA` and `XB` do not have
            the same number of columns.
    
        Notes
        -----
        The following are common calling conventions:
    
        1. ``Y = cdist(XA, XB, 'euclidean')``
    
           Computes the distance between :math:`m` points using
           Euclidean distance (2-norm) as the distance metric between the
           points. The points are arranged as :math:`m`
           :math:`n`-dimensional row vectors in the matrix X.
    
        2. ``Y = cdist(XA, XB, 'minkowski', p=2.)``
    
           Computes the distances using the Minkowski distance
           :math:`||u-v||_p` (:math:`p`-norm) where :math:`p \\geq 1`.
    
        3. ``Y = cdist(XA, XB, 'cityblock')``
    
           Computes the city block or Manhattan distance between the
           points.
    
        4. ``Y = cdist(XA, XB, 'seuclidean', V=None)``
    
           Computes the standardized Euclidean distance. The standardized
           Euclidean distance between two n-vectors ``u`` and ``v`` is
    
           .. math::
    
              \\sqrt{\\sum {(u_i-v_i)^2 / V[x_i]}}.
    
           V is the variance vector; V[i] is the variance computed over all
           the i'th components of the points. If not passed, it is
           automatically computed.
    
        5. ``Y = cdist(XA, XB, 'sqeuclidean')``
    
           Computes the squared Euclidean distance :math:`||u-v||_2^2` between
           the vectors.
    
        6. ``Y = cdist(XA, XB, 'cosine')``
    
           Computes the cosine distance between vectors u and v,
    
           .. math::
    
              1 - \\frac{u \\cdot v}
                       {{||u||}_2 {||v||}_2}
    
           where :math:`||*||_2` is the 2-norm of its argument ``*``, and
           :math:`u \\cdot v` is the dot product of :math:`u` and :math:`v`.
    
        7. ``Y = cdist(XA, XB, 'correlation')``
    
           Computes the correlation distance between vectors u and v. This is
    
           .. math::
    
              1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}
                       {{||(u - \\bar{u})||}_2 {||(v - \\bar{v})||}_2}
    
           where :math:`\\bar{v}` is the mean of the elements of vector v,
           and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.
    
    
        8. ``Y = cdist(XA, XB, 'hamming')``
    
           Computes the normalized Hamming distance, or the proportion of
           those vector elements between two n-vectors ``u`` and ``v``
           which disagree. To save memory, the matrix ``X`` can be of type
           boolean.
    
        9. ``Y = cdist(XA, XB, 'jaccard')``
    
           Computes the Jaccard distance between the points. Given two
           vectors, ``u`` and ``v``, the Jaccard distance is the
           proportion of those elements ``u[i]`` and ``v[i]`` that
           disagree where at least one of them is non-zero.
    
        10. ``Y = cdist(XA, XB, 'jensenshannon')``
    
            Computes the Jensen-Shannon distance between two probability arrays.
            Given two probability vectors, :math:`p` and :math:`q`, the
            Jensen-Shannon distance is
    
            .. math::
    
               \\sqrt{\\frac{D(p \\parallel m) + D(q \\parallel m)}{2}}
    
            where :math:`m` is the pointwise mean of :math:`p` and :math:`q`
            and :math:`D` is the Kullback-Leibler divergence.
    
        11. ``Y = cdist(XA, XB, 'chebyshev')``
    
            Computes the Chebyshev distance between the points. The
            Chebyshev distance between two n-vectors ``u`` and ``v`` is the
            maximum norm-1 distance between their respective elements. More
            precisely, the distance is given by
    
            .. math::
    
               d(u,v) = \\max_i {|u_i-v_i|}.
    
        12. ``Y = cdist(XA, XB, 'canberra')``
    
            Computes the Canberra distance between the points. The
            Canberra distance between two points ``u`` and ``v`` is
    
            .. math::
    
              d(u,v) = \\sum_i \\frac{|u_i-v_i|}
                                   {|u_i|+|v_i|}.
    
        13. ``Y = cdist(XA, XB, 'braycurtis')``
    
            Computes the Bray-Curtis distance between the points. The
            Bray-Curtis distance between two points ``u`` and ``v`` is
    
    
            .. math::
    
                 d(u,v) = \\frac{\\sum_i (|u_i-v_i|)}
                               {\\sum_i (|u_i+v_i|)}
    
        14. ``Y = cdist(XA, XB, 'mahalanobis', VI=None)``
    
            Computes the Mahalanobis distance between the points. The
            Mahalanobis distance between two points ``u`` and ``v`` is
            :math:`\\sqrt{(u-v)(1/V)(u-v)^T}` where :math:`(1/V)` (the ``VI``
            variable) is the inverse covariance. If ``VI`` is not None,
            ``VI`` will be used as the inverse covariance matrix.
    
        15. ``Y = cdist(XA, XB, 'yule')``
    
            Computes the Yule distance between the boolean
            vectors. (see `yule` function documentation)
    
        16. ``Y = cdist(XA, XB, 'matching')``
    
            Synonym for 'hamming'.
    
        17. ``Y = cdist(XA, XB, 'dice')``
    
            Computes the Dice distance between the boolean vectors. (see
            `dice` function documentation)
    
        18. ``Y = cdist(XA, XB, 'kulsinski')``
    
            Computes the Kulsinski distance between the boolean
            vectors. (see `kulsinski` function documentation)
    
        19. ``Y = cdist(XA, XB, 'rogerstanimoto')``
    
            Computes the Rogers-Tanimoto distance between the boolean
            vectors. (see `rogerstanimoto` function documentation)
    
        20. ``Y = cdist(XA, XB, 'russellrao')``
    
            Computes the Russell-Rao distance between the boolean
            vectors. (see `russellrao` function documentation)
    
        21. ``Y = cdist(XA, XB, 'sokalmichener')``
    
            Computes the Sokal-Michener distance between the boolean
            vectors. (see `sokalmichener` function documentation)
    
        22. ``Y = cdist(XA, XB, 'sokalsneath')``
    
            Computes the Sokal-Sneath distance between the vectors. (see
            `sokalsneath` function documentation)
    
    
        23. ``Y = cdist(XA, XB, 'wminkowski', p=2., w=w)``
    
            Computes the weighted Minkowski distance between the
            vectors. (see `wminkowski` function documentation)
    
            'wminkowski' is deprecated and will be removed in SciPy 1.8.0.
            Use 'minkowski' instead.
    
        24. ``Y = cdist(XA, XB, f)``
    
            Computes the distance between all pairs of vectors in X
            using the user supplied 2-arity function f. For example,
            Euclidean distance between the vectors could be computed
            as follows::
    
              dm = cdist(XA, XB, lambda u, v: np.sqrt(((u-v)**2).sum()))
    
            Note that you should avoid passing a reference to one of
            the distance functions defined in this library. For example,::
    
              dm = cdist(XA, XB, sokalsneath)
    
            would calculate the pair-wise distances between the vectors in
            X using the Python function `sokalsneath`. This would result in
            sokalsneath being called :math:`{n \\choose 2}` times, which
            is inefficient. Instead, the optimized C version is more
            efficient, and we call it using the following syntax::
    
              dm = cdist(XA, XB, 'sokalsneath')
    
        Examples
        --------
        Find the Euclidean distances between four 2-D coordinates:
    
        >>> from scipy.spatial import distance
        >>> coords = [(35.0456, -85.2672),
        ...           (35.1174, -89.9711),
        ...           (35.9728, -83.9422),
        ...           (36.1667, -86.7833)]
        >>> distance.cdist(coords, coords, 'euclidean')
        array([[ 0.    ,  4.7044,  1.6172,  1.8856],
               [ 4.7044,  0.    ,  6.0893,  3.3561],
               [ 1.6172,  6.0893,  0.    ,  2.8477],
               [ 1.8856,  3.3561,  2.8477,  0.    ]])
    
    
        Find the Manhattan distance from a 3-D point to the corners of the unit
        cube:
    
        >>> a = np.array([[0, 0, 0],
        ...               [0, 0, 1],
        ...               [0, 1, 0],
        ...               [0, 1, 1],
        ...               [1, 0, 0],
        ...               [1, 0, 1],
        ...               [1, 1, 0],
        ...               [1, 1, 1]])
        >>> b = np.array([[ 0.1,  0.2,  0.4]])
        >>> distance.cdist(a, b, 'cityblock')
        array([[ 0.7],
               [ 0.9],
               [ 1.3],
               [ 1.5],
               [ 1.5],
               [ 1.7],
               [ 2.1],
               [ 2.3]])
    
        """
        # You can also call this as:
        #     Y = cdist(XA, XB, 'test_abc')
        # where 'abc' is the metric being tested.  This computes the distance
        # between all pairs of vectors in XA and XB using the distance metric 'abc'
        # but with a more succinct, verifiable, but less efficient implementation.
    
        XA = np.asarray(XA)
        XB = np.asarray(XB)
    
        s = XA.shape
        sB = XB.shape
    
        if len(s) != 2:
            raise ValueError('XA must be a 2-dimensional array.')
        if len(sB) != 2:
            raise ValueError('XB must be a 2-dimensional array.')
        if s[1] != sB[1]:
            raise ValueError('XA and XB must have the same number of columns '
                             '(i.e. feature dimension.)')
    
        mA = s[0]
        mB = sB[0]
        n = s[1]
    
        if callable(metric):
            mstr = getattr(metric, '__name__', 'Unknown')
            metric_info = _METRIC_ALIAS.get(mstr, None)
            if metric_info is not None:
                XA, XB, typ, kwargs = _validate_cdist_input(
                    XA, XB, mA, mB, n, metric_info, **kwargs)
            return _cdist_callable(XA, XB, metric=metric, out=out, **kwargs)
        elif isinstance(metric, str):
            mstr = metric.lower()
            metric_info = _METRIC_ALIAS.get(mstr, None)
            if metric_info is not None:
                cdist_fn = metric_info.cdist_func
>               return cdist_fn(XA, XB, out=out, **kwargs)
E               ValueError: Unsupported dtype object

../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/scipy/spatial/distance.py:2954: ValueError
_______________________ testPERMDISP.test_centroids_null _______________________

self = <skbio.stats.distance.tests.test_permdisp.testPERMDISP testMethod=test_centroids_null>

    def test_centroids_null(self):
        dm = pcoa(self.null_mat)
        dm = dm.samples
    
>       obs_null = _compute_groups(dm, 'centroid', self.grouping_eq)

../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/stats/distance/tests/test_permdisp.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/stats/distance/_permdisp.py:251: in _compute_groups
    groups.append(cdist(df.values[:, :-1], [centroids.loc[label].values],
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

XA = array([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
       [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
       [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]], dtype=object)
XB = array([[ 0.,  0.,  0.,  0.,  0.,  0.]]), metric = 'euclidean', out = None
kwargs = {}, s = (3, 6), sB = (1, 6), mA = 3, mB = 1, n = 6, mstr = 'euclidean'

    def cdist(XA, XB, metric='euclidean', *, out=None, **kwargs):
        """
        Compute distance between each pair of the two collections of inputs.
    
        See Notes for common calling conventions.
    
        Parameters
        ----------
        XA : array_like
            An :math:`m_A` by :math:`n` array of :math:`m_A`
            original observations in an :math:`n`-dimensional space.
            Inputs are converted to float type.
        XB : array_like
            An :math:`m_B` by :math:`n` array of :math:`m_B`
            original observations in an :math:`n`-dimensional space.
            Inputs are converted to float type.
        metric : str or callable, optional
            The distance metric to use. If a string, the distance function can be
            'braycurtis', 'canberra', 'chebyshev', 'cityblock', 'correlation',
            'cosine', 'dice', 'euclidean', 'hamming', 'jaccard', 'jensenshannon',
            'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto',
            'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath',
            'sqeuclidean', 'wminkowski', 'yule'.
        **kwargs : dict, optional
            Extra arguments to `metric`: refer to each metric documentation for a
            list of all possible arguments.
    
            Some possible arguments:
    
            p : scalar
            The p-norm to apply for Minkowski, weighted and unweighted.
            Default: 2.
    
            w : array_like
            The weight vector for metrics that support weights (e.g., Minkowski).
    
            V : array_like
            The variance vector for standardized Euclidean.
            Default: var(vstack([XA, XB]), axis=0, ddof=1)
    
            VI : array_like
            The inverse of the covariance matrix for Mahalanobis.
            Default: inv(cov(vstack([XA, XB].T))).T
    
            out : ndarray
            The output array
            If not None, the distance matrix Y is stored in this array.
    
        Returns
        -------
        Y : ndarray
            A :math:`m_A` by :math:`m_B` distance matrix is returned.
            For each :math:`i` and :math:`j`, the metric
            ``dist(u=XA[i], v=XB[j])`` is computed and stored in the
            :math:`ij` th entry.
    
        Raises
        ------
        ValueError
            An exception is thrown if `XA` and `XB` do not have
            the same number of columns.
    
        Notes
        -----
        The following are common calling conventions:
    
        1. ``Y = cdist(XA, XB, 'euclidean')``
    
           Computes the distance between :math:`m` points using
           Euclidean distance (2-norm) as the distance metric between the
           points. The points are arranged as :math:`m`
           :math:`n`-dimensional row vectors in the matrix X.
    
        2. ``Y = cdist(XA, XB, 'minkowski', p=2.)``
    
           Computes the distances using the Minkowski distance
           :math:`||u-v||_p` (:math:`p`-norm) where :math:`p \\geq 1`.
    
        3. ``Y = cdist(XA, XB, 'cityblock')``
    
           Computes the city block or Manhattan distance between the
           points.
    
        4. ``Y = cdist(XA, XB, 'seuclidean', V=None)``
    
           Computes the standardized Euclidean distance. The standardized
           Euclidean distance between two n-vectors ``u`` and ``v`` is
    
           .. math::
    
              \\sqrt{\\sum {(u_i-v_i)^2 / V[x_i]}}.
    
           V is the variance vector; V[i] is the variance computed over all
           the i'th components of the points. If not passed, it is
           automatically computed.
    
        5. ``Y = cdist(XA, XB, 'sqeuclidean')``
    
           Computes the squared Euclidean distance :math:`||u-v||_2^2` between
           the vectors.
    
        6. ``Y = cdist(XA, XB, 'cosine')``
    
           Computes the cosine distance between vectors u and v,
    
           .. math::
    
              1 - \\frac{u \\cdot v}
                       {{||u||}_2 {||v||}_2}
    
           where :math:`||*||_2` is the 2-norm of its argument ``*``, and
           :math:`u \\cdot v` is the dot product of :math:`u` and :math:`v`.
    
        7. ``Y = cdist(XA, XB, 'correlation')``
    
           Computes the correlation distance between vectors u and v. This is
    
           .. math::
    
              1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}
                       {{||(u - \\bar{u})||}_2 {||(v - \\bar{v})||}_2}
    
           where :math:`\\bar{v}` is the mean of the elements of vector v,
           and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.
    
    
        8. ``Y = cdist(XA, XB, 'hamming')``
    
           Computes the normalized Hamming distance, or the proportion of
           those vector elements between two n-vectors ``u`` and ``v``
           which disagree. To save memory, the matrix ``X`` can be of type
           boolean.
    
        9. ``Y = cdist(XA, XB, 'jaccard')``
    
           Computes the Jaccard distance between the points. Given two
           vectors, ``u`` and ``v``, the Jaccard distance is the
           proportion of those elements ``u[i]`` and ``v[i]`` that
           disagree where at least one of them is non-zero.
    
        10. ``Y = cdist(XA, XB, 'jensenshannon')``
    
            Computes the Jensen-Shannon distance between two probability arrays.
            Given two probability vectors, :math:`p` and :math:`q`, the
            Jensen-Shannon distance is
    
            .. math::
    
               \\sqrt{\\frac{D(p \\parallel m) + D(q \\parallel m)}{2}}
    
            where :math:`m` is the pointwise mean of :math:`p` and :math:`q`
            and :math:`D` is the Kullback-Leibler divergence.
    
        11. ``Y = cdist(XA, XB, 'chebyshev')``
    
            Computes the Chebyshev distance between the points. The
            Chebyshev distance between two n-vectors ``u`` and ``v`` is the
            maximum norm-1 distance between their respective elements. More
            precisely, the distance is given by
    
            .. math::
    
               d(u,v) = \\max_i {|u_i-v_i|}.
    
        12. ``Y = cdist(XA, XB, 'canberra')``
    
            Computes the Canberra distance between the points. The
            Canberra distance between two points ``u`` and ``v`` is
    
            .. math::
    
              d(u,v) = \\sum_i \\frac{|u_i-v_i|}
                                   {|u_i|+|v_i|}.
    
        13. ``Y = cdist(XA, XB, 'braycurtis')``
    
            Computes the Bray-Curtis distance between the points. The
            Bray-Curtis distance between two points ``u`` and ``v`` is
    
    
            .. math::
    
                 d(u,v) = \\frac{\\sum_i (|u_i-v_i|)}
                               {\\sum_i (|u_i+v_i|)}
    
        14. ``Y = cdist(XA, XB, 'mahalanobis', VI=None)``
    
            Computes the Mahalanobis distance between the points. The
            Mahalanobis distance between two points ``u`` and ``v`` is
            :math:`\\sqrt{(u-v)(1/V)(u-v)^T}` where :math:`(1/V)` (the ``VI``
            variable) is the inverse covariance. If ``VI`` is not None,
            ``VI`` will be used as the inverse covariance matrix.
    
        15. ``Y = cdist(XA, XB, 'yule')``
    
            Computes the Yule distance between the boolean
            vectors. (see `yule` function documentation)
    
        16. ``Y = cdist(XA, XB, 'matching')``
    
            Synonym for 'hamming'.
    
        17. ``Y = cdist(XA, XB, 'dice')``
    
            Computes the Dice distance between the boolean vectors. (see
            `dice` function documentation)
    
        18. ``Y = cdist(XA, XB, 'kulsinski')``
    
            Computes the Kulsinski distance between the boolean
            vectors. (see `kulsinski` function documentation)
    
        19. ``Y = cdist(XA, XB, 'rogerstanimoto')``
    
            Computes the Rogers-Tanimoto distance between the boolean
            vectors. (see `rogerstanimoto` function documentation)
    
        20. ``Y = cdist(XA, XB, 'russellrao')``
    
            Computes the Russell-Rao distance between the boolean
            vectors. (see `russellrao` function documentation)
    
        21. ``Y = cdist(XA, XB, 'sokalmichener')``
    
            Computes the Sokal-Michener distance between the boolean
            vectors. (see `sokalmichener` function documentation)
    
        22. ``Y = cdist(XA, XB, 'sokalsneath')``
    
            Computes the Sokal-Sneath distance between the vectors. (see
            `sokalsneath` function documentation)
    
    
        23. ``Y = cdist(XA, XB, 'wminkowski', p=2., w=w)``
    
            Computes the weighted Minkowski distance between the
            vectors. (see `wminkowski` function documentation)
    
            'wminkowski' is deprecated and will be removed in SciPy 1.8.0.
            Use 'minkowski' instead.
    
        24. ``Y = cdist(XA, XB, f)``
    
            Computes the distance between all pairs of vectors in X
            using the user supplied 2-arity function f. For example,
            Euclidean distance between the vectors could be computed
            as follows::
    
              dm = cdist(XA, XB, lambda u, v: np.sqrt(((u-v)**2).sum()))
    
            Note that you should avoid passing a reference to one of
            the distance functions defined in this library. For example,::
    
              dm = cdist(XA, XB, sokalsneath)
    
            would calculate the pair-wise distances between the vectors in
            X using the Python function `sokalsneath`. This would result in
            sokalsneath being called :math:`{n \\choose 2}` times, which
            is inefficient. Instead, the optimized C version is more
            efficient, and we call it using the following syntax::
    
              dm = cdist(XA, XB, 'sokalsneath')
    
        Examples
        --------
        Find the Euclidean distances between four 2-D coordinates:
    
        >>> from scipy.spatial import distance
        >>> coords = [(35.0456, -85.2672),
        ...           (35.1174, -89.9711),
        ...           (35.9728, -83.9422),
        ...           (36.1667, -86.7833)]
        >>> distance.cdist(coords, coords, 'euclidean')
        array([[ 0.    ,  4.7044,  1.6172,  1.8856],
               [ 4.7044,  0.    ,  6.0893,  3.3561],
               [ 1.6172,  6.0893,  0.    ,  2.8477],
               [ 1.8856,  3.3561,  2.8477,  0.    ]])
    
    
        Find the Manhattan distance from a 3-D point to the corners of the unit
        cube:
    
        >>> a = np.array([[0, 0, 0],
        ...               [0, 0, 1],
        ...               [0, 1, 0],
        ...               [0, 1, 1],
        ...               [1, 0, 0],
        ...               [1, 0, 1],
        ...               [1, 1, 0],
        ...               [1, 1, 1]])
        >>> b = np.array([[ 0.1,  0.2,  0.4]])
        >>> distance.cdist(a, b, 'cityblock')
        array([[ 0.7],
               [ 0.9],
               [ 1.3],
               [ 1.5],
               [ 1.5],
               [ 1.7],
               [ 2.1],
               [ 2.3]])
    
        """
        # You can also call this as:
        #     Y = cdist(XA, XB, 'test_abc')
        # where 'abc' is the metric being tested.  This computes the distance
        # between all pairs of vectors in XA and XB using the distance metric 'abc'
        # but with a more succinct, verifiable, but less efficient implementation.
    
        XA = np.asarray(XA)
        XB = np.asarray(XB)
    
        s = XA.shape
        sB = XB.shape
    
        if len(s) != 2:
            raise ValueError('XA must be a 2-dimensional array.')
        if len(sB) != 2:
            raise ValueError('XB must be a 2-dimensional array.')
        if s[1] != sB[1]:
            raise ValueError('XA and XB must have the same number of columns '
                             '(i.e. feature dimension.)')
    
        mA = s[0]
        mB = sB[0]
        n = s[1]
    
        if callable(metric):
            mstr = getattr(metric, '__name__', 'Unknown')
            metric_info = _METRIC_ALIAS.get(mstr, None)
            if metric_info is not None:
                XA, XB, typ, kwargs = _validate_cdist_input(
                    XA, XB, mA, mB, n, metric_info, **kwargs)
            return _cdist_callable(XA, XB, metric=metric, out=out, **kwargs)
        elif isinstance(metric, str):
            mstr = metric.lower()
            metric_info = _METRIC_ALIAS.get(mstr, None)
            if metric_info is not None:
                cdist_fn = metric_info.cdist_func
>               return cdist_fn(XA, XB, out=out, **kwargs)
E               ValueError: Unsupported dtype object

../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/scipy/spatial/distance.py:2954: ValueError
___________________ testPERMDISP.test_centroids_uneq_groups ____________________

self = <skbio.stats.distance.tests.test_permdisp.testPERMDISP testMethod=test_centroids_uneq_groups>

    def test_centroids_uneq_groups(self):
        """
        the expected result here was calculated by hand
        """
        exp = [[2.5847022428144935, 2.285624595858895,
                1.7022431146340287],
               [1.724817266046108, 1.724817266046108],
               [2.4333280644972795, 2.389000390879655,
                2.8547180589306036, 3.218568759338847]]
        exp_stat, _ = f_oneway(*exp)
    
        dm = pcoa(self.uneq_mat)
        dm = dm.samples
    
>       obs = _compute_groups(dm, 'centroid', self.grouping_uneq)

../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/stats/distance/tests/test_permdisp.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/stats/distance/_permdisp.py:251: in _compute_groups
    groups.append(cdist(df.values[:, :-1], [centroids.loc[label].values],
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

XA = array([[1.0559100095568086, 1.5297925821761884, 1.5885925999277586,
        -0.27423308995024553, -0.9980655246587443,...5152868578, -1.8614901635882684,
        0.018065319797415245, 0.18781865676804546, 0.0, 0.0, 0.0, 0.0]], dtype=object)
XB = array([[ 0.96679999,  0.24357552, -0.42381734,  0.41217343, -0.29276908,
         0.        ,  0.        ,  0.        ,  0.        ]])
metric = 'euclidean', out = None, kwargs = {}, s = (3, 9), sB = (1, 9), mA = 3
mB = 1, n = 9, mstr = 'euclidean'

    def cdist(XA, XB, metric='euclidean', *, out=None, **kwargs):
        """
        Compute distance between each pair of the two collections of inputs.
    
        See Notes for common calling conventions.
    
        Parameters
        ----------
        XA : array_like
            An :math:`m_A` by :math:`n` array of :math:`m_A`
            original observations in an :math:`n`-dimensional space.
            Inputs are converted to float type.
        XB : array_like
            An :math:`m_B` by :math:`n` array of :math:`m_B`
            original observations in an :math:`n`-dimensional space.
            Inputs are converted to float type.
        metric : str or callable, optional
            The distance metric to use. If a string, the distance function can be
            'braycurtis', 'canberra', 'chebyshev', 'cityblock', 'correlation',
            'cosine', 'dice', 'euclidean', 'hamming', 'jaccard', 'jensenshannon',
            'kulsinski', 'mahalanobis', 'matching', 'minkowski', 'rogerstanimoto',
            'russellrao', 'seuclidean', 'sokalmichener', 'sokalsneath',
            'sqeuclidean', 'wminkowski', 'yule'.
        **kwargs : dict, optional
            Extra arguments to `metric`: refer to each metric documentation for a
            list of all possible arguments.
    
            Some possible arguments:
    
            p : scalar
            The p-norm to apply for Minkowski, weighted and unweighted.
            Default: 2.
    
            w : array_like
            The weight vector for metrics that support weights (e.g., Minkowski).
    
            V : array_like
            The variance vector for standardized Euclidean.
            Default: var(vstack([XA, XB]), axis=0, ddof=1)
    
            VI : array_like
            The inverse of the covariance matrix for Mahalanobis.
            Default: inv(cov(vstack([XA, XB].T))).T
    
            out : ndarray
            The output array
            If not None, the distance matrix Y is stored in this array.
    
        Returns
        -------
        Y : ndarray
            A :math:`m_A` by :math:`m_B` distance matrix is returned.
            For each :math:`i` and :math:`j`, the metric
            ``dist(u=XA[i], v=XB[j])`` is computed and stored in the
            :math:`ij` th entry.
    
        Raises
        ------
        ValueError
            An exception is thrown if `XA` and `XB` do not have
            the same number of columns.
    
        Notes
        -----
        The following are common calling conventions:
    
        1. ``Y = cdist(XA, XB, 'euclidean')``
    
           Computes the distance between :math:`m` points using
           Euclidean distance (2-norm) as the distance metric between the
           points. The points are arranged as :math:`m`
           :math:`n`-dimensional row vectors in the matrix X.
    
        2. ``Y = cdist(XA, XB, 'minkowski', p=2.)``
    
           Computes the distances using the Minkowski distance
           :math:`||u-v||_p` (:math:`p`-norm) where :math:`p \\geq 1`.
    
        3. ``Y = cdist(XA, XB, 'cityblock')``
    
           Computes the city block or Manhattan distance between the
           points.
    
        4. ``Y = cdist(XA, XB, 'seuclidean', V=None)``
    
           Computes the standardized Euclidean distance. The standardized
           Euclidean distance between two n-vectors ``u`` and ``v`` is
    
           .. math::
    
              \\sqrt{\\sum {(u_i-v_i)^2 / V[x_i]}}.
    
           V is the variance vector; V[i] is the variance computed over all
           the i'th components of the points. If not passed, it is
           automatically computed.
    
        5. ``Y = cdist(XA, XB, 'sqeuclidean')``
    
           Computes the squared Euclidean distance :math:`||u-v||_2^2` between
           the vectors.
    
        6. ``Y = cdist(XA, XB, 'cosine')``
    
           Computes the cosine distance between vectors u and v,
    
           .. math::
    
              1 - \\frac{u \\cdot v}
                       {{||u||}_2 {||v||}_2}
    
           where :math:`||*||_2` is the 2-norm of its argument ``*``, and
           :math:`u \\cdot v` is the dot product of :math:`u` and :math:`v`.
    
        7. ``Y = cdist(XA, XB, 'correlation')``
    
           Computes the correlation distance between vectors u and v. This is
    
           .. math::
    
              1 - \\frac{(u - \\bar{u}) \\cdot (v - \\bar{v})}
                       {{||(u - \\bar{u})||}_2 {||(v - \\bar{v})||}_2}
    
           where :math:`\\bar{v}` is the mean of the elements of vector v,
           and :math:`x \\cdot y` is the dot product of :math:`x` and :math:`y`.
    
    
        8. ``Y = cdist(XA, XB, 'hamming')``
    
           Computes the normalized Hamming distance, or the proportion of
           those vector elements between two n-vectors ``u`` and ``v``
           which disagree. To save memory, the matrix ``X`` can be of type
           boolean.
    
        9. ``Y = cdist(XA, XB, 'jaccard')``
    
           Computes the Jaccard distance between the points. Given two
           vectors, ``u`` and ``v``, the Jaccard distance is the
           proportion of those elements ``u[i]`` and ``v[i]`` that
           disagree where at least one of them is non-zero.
    
        10. ``Y = cdist(XA, XB, 'jensenshannon')``
    
            Computes the Jensen-Shannon distance between two probability arrays.
            Given two probability vectors, :math:`p` and :math:`q`, the
            Jensen-Shannon distance is
    
            .. math::
    
               \\sqrt{\\frac{D(p \\parallel m) + D(q \\parallel m)}{2}}
    
            where :math:`m` is the pointwise mean of :math:`p` and :math:`q`
            and :math:`D` is the Kullback-Leibler divergence.
    
        11. ``Y = cdist(XA, XB, 'chebyshev')``
    
            Computes the Chebyshev distance between the points. The
            Chebyshev distance between two n-vectors ``u`` and ``v`` is the
            maximum norm-1 distance between their respective elements. More
            precisely, the distance is given by
    
            .. math::
    
               d(u,v) = \\max_i {|u_i-v_i|}.
    
        12. ``Y = cdist(XA, XB, 'canberra')``
    
            Computes the Canberra distance between the points. The
            Canberra distance between two points ``u`` and ``v`` is
    
            .. math::
    
              d(u,v) = \\sum_i \\frac{|u_i-v_i|}
                                   {|u_i|+|v_i|}.
    
        13. ``Y = cdist(XA, XB, 'braycurtis')``
    
            Computes the Bray-Curtis distance between the points. The
            Bray-Curtis distance between two points ``u`` and ``v`` is
    
    
            .. math::
    
                 d(u,v) = \\frac{\\sum_i (|u_i-v_i|)}
                               {\\sum_i (|u_i+v_i|)}
    
        14. ``Y = cdist(XA, XB, 'mahalanobis', VI=None)``
    
            Computes the Mahalanobis distance between the points. The
            Mahalanobis distance between two points ``u`` and ``v`` is
            :math:`\\sqrt{(u-v)(1/V)(u-v)^T}` where :math:`(1/V)` (the ``VI``
            variable) is the inverse covariance. If ``VI`` is not None,
            ``VI`` will be used as the inverse covariance matrix.
    
        15. ``Y = cdist(XA, XB, 'yule')``
    
            Computes the Yule distance between the boolean
            vectors. (see `yule` function documentation)
    
        16. ``Y = cdist(XA, XB, 'matching')``
    
            Synonym for 'hamming'.
    
        17. ``Y = cdist(XA, XB, 'dice')``
    
            Computes the Dice distance between the boolean vectors. (see
            `dice` function documentation)
    
        18. ``Y = cdist(XA, XB, 'kulsinski')``
    
            Computes the Kulsinski distance between the boolean
            vectors. (see `kulsinski` function documentation)
    
        19. ``Y = cdist(XA, XB, 'rogerstanimoto')``
    
            Computes the Rogers-Tanimoto distance between the boolean
            vectors. (see `rogerstanimoto` function documentation)
    
        20. ``Y = cdist(XA, XB, 'russellrao')``
    
            Computes the Russell-Rao distance between the boolean
            vectors. (see `russellrao` function documentation)
    
        21. ``Y = cdist(XA, XB, 'sokalmichener')``
    
            Computes the Sokal-Michener distance between the boolean
            vectors. (see `sokalmichener` function documentation)
    
        22. ``Y = cdist(XA, XB, 'sokalsneath')``
    
            Computes the Sokal-Sneath distance between the vectors. (see
            `sokalsneath` function documentation)
    
    
        23. ``Y = cdist(XA, XB, 'wminkowski', p=2., w=w)``
    
            Computes the weighted Minkowski distance between the
            vectors. (see `wminkowski` function documentation)
    
            'wminkowski' is deprecated and will be removed in SciPy 1.8.0.
            Use 'minkowski' instead.
    
        24. ``Y = cdist(XA, XB, f)``
    
            Computes the distance between all pairs of vectors in X
            using the user supplied 2-arity function f. For example,
            Euclidean distance between the vectors could be computed
            as follows::
    
              dm = cdist(XA, XB, lambda u, v: np.sqrt(((u-v)**2).sum()))
    
            Note that you should avoid passing a reference to one of
            the distance functions defined in this library. For example,::
    
              dm = cdist(XA, XB, sokalsneath)
    
            would calculate the pair-wise distances between the vectors in
            X using the Python function `sokalsneath`. This would result in
            sokalsneath being called :math:`{n \\choose 2}` times, which
            is inefficient. Instead, the optimized C version is more
            efficient, and we call it using the following syntax::
    
              dm = cdist(XA, XB, 'sokalsneath')
    
        Examples
        --------
        Find the Euclidean distances between four 2-D coordinates:
    
        >>> from scipy.spatial import distance
        >>> coords = [(35.0456, -85.2672),
        ...           (35.1174, -89.9711),
        ...           (35.9728, -83.9422),
        ...           (36.1667, -86.7833)]
        >>> distance.cdist(coords, coords, 'euclidean')
        array([[ 0.    ,  4.7044,  1.6172,  1.8856],
               [ 4.7044,  0.    ,  6.0893,  3.3561],
               [ 1.6172,  6.0893,  0.    ,  2.8477],
               [ 1.8856,  3.3561,  2.8477,  0.    ]])
    
    
        Find the Manhattan distance from a 3-D point to the corners of the unit
        cube:
    
        >>> a = np.array([[0, 0, 0],
        ...               [0, 0, 1],
        ...               [0, 1, 0],
        ...               [0, 1, 1],
        ...               [1, 0, 0],
        ...               [1, 0, 1],
        ...               [1, 1, 0],
        ...               [1, 1, 1]])
        >>> b = np.array([[ 0.1,  0.2,  0.4]])
        >>> distance.cdist(a, b, 'cityblock')
        array([[ 0.7],
               [ 0.9],
               [ 1.3],
               [ 1.5],
               [ 1.5],
               [ 1.7],
               [ 2.1],
               [ 2.3]])
    
        """
        # You can also call this as:
        #     Y = cdist(XA, XB, 'test_abc')
        # where 'abc' is the metric being tested.  This computes the distance
        # between all pairs of vectors in XA and XB using the distance metric 'abc'
        # but with a more succinct, verifiable, but less efficient implementation.
    
        XA = np.asarray(XA)
        XB = np.asarray(XB)
    
        s = XA.shape
        sB = XB.shape
    
        if len(s) != 2:
            raise ValueError('XA must be a 2-dimensional array.')
        if len(sB) != 2:
            raise ValueError('XB must be a 2-dimensional array.')
        if s[1] != sB[1]:
            raise ValueError('XA and XB must have the same number of columns '
                             '(i.e. feature dimension.)')
    
        mA = s[0]
        mB = sB[0]
        n = s[1]
    
        if callable(metric):
            mstr = getattr(metric, '__name__', 'Unknown')
            metric_info = _METRIC_ALIAS.get(mstr, None)
            if metric_info is not None:
                XA, XB, typ, kwargs = _validate_cdist_input(
                    XA, XB, mA, mB, n, metric_info, **kwargs)
            return _cdist_callable(XA, XB, metric=metric, out=out, **kwargs)
        elif isinstance(metric, str):
            mstr = metric.lower()
            metric_info = _METRIC_ALIAS.get(mstr, None)
            if metric_info is not None:
                cdist_fn = metric_info.cdist_func
>               return cdist_fn(XA, XB, out=out, **kwargs)
E               ValueError: Unsupported dtype object

../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/scipy/spatial/distance.py:2954: ValueError
_____________________ GradientTests.test_weight_by_vector ______________________

self = <skbio.stats.tests.test_gradient.GradientTests testMethod=test_weight_by_vector>

    def test_weight_by_vector(self):
        """Correctly weights the vectors"""
        trajectory = pd.DataFrame.from_dict({'s1': np.array([1]),
                                             's2': np.array([2]),
                                             's3': np.array([3]),
                                             's4': np.array([4]),
                                             's5': np.array([5]),
                                             's6': np.array([6]),
                                             's7': np.array([7]),
                                             's8': np.array([8])},
                                            orient='index')
        trajectory.sort_values(by=0, inplace=True)
        w_vector = pd.Series(np.array([1, 5, 8, 12, 45, 80, 85, 90]),
                             ['s1', 's2', 's3', 's4',
                              's5', 's6', 's7', 's8']).astype(np.float64)
        exp = pd.DataFrame.from_dict({'s1': np.array([1]),
                                      's2': np.array([6.3571428571]),
                                      's3': np.array([12.7142857142]),
                                      's4': np.array([12.7142857142]),
                                      's5': np.array([1.9264069264]),
                                      's6': np.array([2.1795918367]),
                                      's7': np.array([17.8]),
                                      's8': np.array([20.3428571428])},
                                     orient='index')
        obs = _weight_by_vector(trajectory, w_vector)
        assert_data_frame_almost_equal(obs.sort_index(), exp.sort_index())
    
        trajectory = pd.DataFrame.from_dict({'s1': np.array([1]),
                                             's2': np.array([2]),
                                             's3': np.array([3]),
                                             's4': np.array([4]),
                                             's5': np.array([5]),
                                             's6': np.array([6]),
                                             's7': np.array([7]),
                                             's8': np.array([8])},
                                            orient='index')
        trajectory.sort_values(by=0, inplace=True)
        w_vector = pd.Series(np.array([1, 2, 3, 4, 5, 6, 7, 8]),
                             ['s1', 's2', 's3', 's4',
                              's5', 's6', 's7', 's8']).astype(np.float64)
        exp = pd.DataFrame.from_dict({'s1': np.array([1.0]),
                                      's2': np.array([2.0]),
                                      's3': np.array([3.0]),
                                      's4': np.array([4.0]),
                                      's5': np.array([5.0]),
                                      's6': np.array([6.0]),
                                      's7': np.array([7.0]),
                                      's8': np.array([8.0])
                                      },
                                     orient='index')
        obs = _weight_by_vector(trajectory, w_vector)
>       assert_data_frame_almost_equal(obs.sort_index(), exp.sort_index())

../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/stats/tests/test_gradient.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

left =     0
s1  1
s2  2
s3  3
s4  4
s5  5
s6  6
s7  7
s8  8
right =       0
s1  1.0
s2  2.0
s3  3.0
s4  4.0
s5  5.0
s6  6.0
s7  7.0
s8  8.0

    @experimental(as_of="0.4.0")
    def assert_data_frame_almost_equal(left, right):
        """Raise AssertionError if ``pd.DataFrame`` objects are not "almost equal".
    
        Wrapper of ``pd.util.testing.assert_frame_equal``. Floating point values
        are considered "almost equal" if they are within a threshold defined by
        ``assert_frame_equal``. This wrapper uses a number of
        checks that are turned off by default in ``assert_frame_equal`` in order to
        perform stricter comparisons (for example, ensuring the index and column
        types are the same). It also does not consider empty ``pd.DataFrame``
        objects equal if they have a different index.
    
        Other notes:
    
        * Index (row) and column ordering must be the same for objects to be equal.
        * NaNs (``np.nan``) in the same locations are considered equal.
    
        This is a helper function intended to be used in unit tests that need to
        compare ``pd.DataFrame`` objects.
    
        Parameters
        ----------
        left, right : pd.DataFrame
            ``pd.DataFrame`` objects to compare.
    
        Raises
        ------
        AssertionError
            If `left` and `right` are not "almost equal".
    
        See Also
        --------
        pandas.util.testing.assert_frame_equal
    
        """
        # pass all kwargs to ensure this function has consistent behavior even if
        # `assert_frame_equal`'s defaults change
>       pdt.assert_frame_equal(left, right,
                               check_dtype=True,
                               check_index_type=True,
                               check_column_type=True,
                               check_frame_type=True,
                               check_less_precise=False,
                               check_names=True,
                               by_blocks=False,
                               check_exact=False)
E       AssertionError: Attributes of DataFrame.iloc[:, 0] (column name="0") are different
E       
E       Attribute "dtype" are different
E       [left]:  int64
E       [right]: float64

../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/util/_testing.py:285: AssertionError
=============================== warnings summary ===============================
../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/util/_exception.py:10
  $PREFIX/lib/python3.9/site-packages/skbio/util/_exception.py:10: PytestCollectionWarning: cannot collect test class 'TestingUtilError' because it has a __init__ constructor (from: io/tests/test_registry.py)
    class TestingUtilError(Exception):

../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/sequence/tests/test_sequence.py:14
  $PREFIX/lib/python3.9/site-packages/skbio/sequence/tests/test_sequence.py:14: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated since Python 3.3, and in 3.10 it will stop working
    from collections import Hashable

../_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehol/lib/python3.9/site-packages/skbio/stats/distance/tests/test_permanova.py:15
  $PREFIX/lib/python3.9/site-packages/skbio/stats/distance/tests/test_permanova.py:15: FutureWarning: pandas.util.testing is deprecated. Use the functions in the public API at pandas.testing instead.
    from pandas.util.testing import assert_series_equal

alignment/__init__.py: 8 warnings
alignment/_tabular_msa.py: 59 warnings
alignment/tests/test_ssw.py: 6 warnings
alignment/tests/test_tabular_msa.py: 3720 warnings
io/format/clustal.py: 2 warnings
io/format/fasta.py: 2 warnings
io/format/fastq.py: 1 warning
io/format/phylip.py: 1 warning
io/format/stockholm.py: 1 warning
io/format/tests/test_clustal.py: 18 warnings
io/format/tests/test_fasta.py: 30 warnings
io/format/tests/test_fastq.py: 83 warnings
io/format/tests/test_phylip.py: 34 warnings
io/format/tests/test_stockholm.py: 79 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/alignment/_tabular_msa.py:784: DeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.
    self._seqs = pd.Series([])

alignment/__init__.py: 1010 warnings
alignment/_tabular_msa.py: 143 warnings
alignment/tests/test_ssw.py: 18 warnings
alignment/tests/test_tabular_msa.py: 5640 warnings
io/format/clustal.py: 9 warnings
io/format/embl.py: 12 warnings
io/format/fasta.py: 25 warnings
io/format/fastq.py: 5 warnings
io/format/genbank.py: 7 warnings
io/format/gff3.py: 4 warnings
io/format/phylip.py: 9 warnings
io/format/qseq.py: 2 warnings
io/format/stockholm.py: 10 warnings
io/format/tests/test_base.py: 14 warnings
io/format/tests/test_clustal.py: 57 warnings
io/format/tests/test_embl.py: 40 warnings
io/format/tests/test_fasta.py: 1632 warnings
io/format/tests/test_fastq.py: 652 warnings
io/format/tests/test_genbank.py: 34 warnings
io/format/tests/test_gff3.py: 6 warnings
io/format/tests/test_phylip.py: 55 warnings
io/format/tests/test_qseq.py: 108 warnings
io/format/tests/test_stockholm.py: 58 warnings
io/tests/test_registry.py: 6 warnings
metadata/_mixin.py: 1 warning
sequence/__init__.py: 22 warnings
sequence/_dna.py: 16 warnings
sequence/_genetic_code.py: 22 warnings
sequence/_grammared_sequence.py: 17 warnings
sequence/_nucleotide_mixin.py: 10 warnings
sequence/_protein.py: 2 warnings
sequence/_rna.py: 13 warnings
sequence/_sequence.py: 78 warnings
sequence/distance.py: 14 warnings
sequence/tests/test_distance.py: 251 warnings
sequence/tests/test_dna.py: 29 warnings
sequence/tests/test_genetic_code.py: 1818 warnings
sequence/tests/test_grammared_sequence.py: 104 warnings
sequence/tests/test_nucleotide_sequences.py: 264 warnings
sequence/tests/test_protein.py: 6 warnings
sequence/tests/test_rna.py: 29 warnings
sequence/tests/test_sequence.py: 1413 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/sequence/_sequence.py:427: DeprecationWarning: tostring() is deprecated. Use tobytes() instead.
    return self._bytes.tostring()

alignment/__init__.py::skbio.alignment
  $PREFIX/lib/python3.9/site-packages/skbio/alignment/_pairwise.py:318: EfficiencyWarning: You're using skbio's python implementation of Smith-Waterman alignment. This will be very slow (e.g., thousands of times slower) than skbio.alignment.local_pairwise_align_ssw.
    warn("You're using skbio's python implementation of Smith-Waterman "

alignment/__init__.py::skbio.alignment
  $PREFIX/lib/python3.9/site-packages/skbio/alignment/_pairwise.py:796: DeprecationWarning: `np.int` is a deprecated alias for the builtin `int`. To silence this warning, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    traceback_matrix = np.zeros(shape, dtype=np.int)

alignment/__init__.py::skbio.alignment
  $PREFIX/lib/python3.9/site-packages/skbio/util/_decorator.py:254: DeprecationWarning: make_identity_substitution_matrix is deprecated as of scikit-bio version 0.4.0, and will be removed in version 0.6.0. Will be replaced by a SubstitutionMatrix class. To track progress, see [#161](https://github.com/biocore/scikit-bio/issues/161).
    warnings.warn('%s is deprecated as of scikit-bio version %s, and '

alignment/__init__.py::skbio.alignment
  $PREFIX/lib/python3.9/site-packages/skbio/alignment/_pairwise.py:595: EfficiencyWarning: You're using skbio's python implementation of Needleman-Wunsch alignment. This is known to be very slow (e.g., thousands of times slower than a native C implementation). We'll be adding a faster version soon (see https://github.com/biocore/scikit-bio/issues/254 to track progress on this).
    warn("You're using skbio's python implementation of Needleman-Wunsch "

alignment/__init__.py::skbio.alignment
  $PREFIX/lib/python3.9/site-packages/skbio/alignment/_pairwise.py:829: DeprecationWarning: `np.int` is a deprecated alias for the builtin `int`. To silence this warning, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    traceback_matrix = np.zeros(shape, dtype=np.int)

alignment/_tabular_msa.py: 2 warnings
alignment/tests/test_tabular_msa.py: 496 warnings
io/format/tests/test_clustal.py: 1 warning
io/format/tests/test_fasta.py: 9 warnings
io/format/tests/test_fastq.py: 12 warnings
io/format/tests/test_phylip.py: 2 warnings
io/format/tests/test_stockholm.py: 47 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/alignment/_tabular_msa.py:1991: DeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.
    self._seqs = pd.Series(sequences, index=index)

alignment/_tabular_msa.py: 5 warnings
alignment/tests/test_tabular_msa.py: 62 warnings
io/format/tests/test_embl.py: 14 warnings
sequence/_sequence.py: 2 warnings
sequence/tests/test_sequence.py: 18 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/sequence/_sequence.py:1815: DeprecationWarning: tostring() is deprecated. Use tobytes() instead.
    chars = indices.astype(np.uint8).tostring().decode('ascii')

alignment/tests/test_tabular_msa.py: 26 warnings
io/format/tests/test_blast6.py: 6 warnings
io/format/tests/test_blast7.py: 8 warnings
metadata/tests/test_mixin.py: 22 warnings
sequence/tests/test_grammared_sequence.py: 2 warnings
sequence/tests/test_sequence.py: 29 warnings
stats/distance/tests/test_base.py: 3 warnings
stats/distance/tests/test_bioenv.py: 8 warnings
stats/distance/tests/test_mantel.py: 9 warnings
stats/tests/test_composition.py: 21 warnings
stats/tests/test_gradient.py: 4 warnings
util/tests/test_testing.py: 2 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/util/_testing.py:285: FutureWarning: The 'check_less_precise' keyword in testing.assert_*_equal is deprecated and will be removed in a future version. You can stop passing 'check_less_precise' to silence this warning.
    pdt.assert_frame_equal(left, right,

alignment/tests/test_tabular_msa.py::TestLoc::test_multiindex_complicated_axis
alignment/tests/test_tabular_msa.py::TestLoc::test_multiindex_complicated_axis_empty_selection
  $PREFIX/lib/python3.9/site-packages/skbio/alignment/_indexing.py:116: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
    indexable = np.asarray(list(indexable))

alignment/tests/test_tabular_msa.py::TestExtend::test_non_empty_msa_empty_iterable
alignment/tests/test_tabular_msa.py::TestExtend::test_reset_index_non_empty_msa_empty_iterable
  $PREFIX/lib/python3.9/site-packages/skbio/alignment/_tabular_msa.py:1986: DeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.
    self._seqs = self._seqs.append(pd.Series(sequences, index=index))

alignment/tests/test_tabular_msa.py: 4 warnings
io/format/tests/test_fasta.py: 52 warnings
io/format/tests/test_fastq.py: 75 warnings
sequence/__init__.py: 2 warnings
sequence/_grammared_sequence.py: 1 warning
sequence/_sequence.py: 9 warnings
sequence/tests/test_nucleotide_sequences.py: 4 warnings
sequence/tests/test_protein.py: 1 warning
sequence/tests/test_sequence.py: 126 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/sequence/_sequence.py:2135: DeprecationWarning: `np.bool` is a deprecated alias for the builtin `bool`. To silence this warning, use `bool` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.bool_` here.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    if sliceable.dtype == np.bool:

alignment/tests/test_tabular_msa.py::TestGapFrequencies::test_no_positions_relative
  $PREFIX/lib/python3.9/site-packages/skbio/alignment/_tabular_msa.py:1653: RuntimeWarning: invalid value encountered in true_divide
    gap_freqs /= length

diversity/__init__.py: 1 warning
stats/distance/_mantel.py: 3 warnings
stats/distance/tests/test_mantel.py: 71 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/stats/distance/_mantel.py:285: DeprecationWarning: `np.float` is a deprecated alias for the builtin `float`. To silence this warning, use `float` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.float64` here.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    permuted_stats = np.fromiter(perm_gen, np.float, count=permutations)

diversity/__init__.py::skbio.diversity
  $PREFIX/lib/python3.9/site-packages/skbio/stats/ordination/_principal_coordinate_analysis.py:143: RuntimeWarning: The result contains negative eigenvalues. Please compare their magnitude with the magnitude of some of the largest positive eigenvalues. If the negative ones are smaller, it's probably safe to ignore them, but if they are large in magnitude, the results won't be useful. See the Notes section for more details. The smallest eigenvalue is -0.011492611219229272 and the largest is 16.021722090908206.
    warn(

diversity/__init__.py::skbio.diversity
stats/ordination/_ordination_results.py::skbio.stats.ordination._ordination_results.OrdinationResults.plot
stats/ordination/tests/test_ordination_results.py::TestOrdinationResults::test_plot_no_metadata
stats/ordination/tests/test_ordination_results.py::TestOrdinationResults::test_plot_with_categorical_metadata_and_plot_options
stats/ordination/tests/test_ordination_results.py::TestOrdinationResults::test_plot_with_numeric_metadata_and_plot_options
stats/ordination/tests/test_ordination_results.py::TestOrdinationResults::test_png
stats/ordination/tests/test_ordination_results.py::TestOrdinationResults::test_repr_png
stats/ordination/tests/test_ordination_results.py::TestOrdinationResults::test_repr_svg
stats/ordination/tests/test_ordination_results.py::TestOrdinationResults::test_svg
  $PREFIX/lib/python3.9/site-packages/skbio/stats/ordination/_ordination_results.py:285: UserWarning: Tight layout not applied. The left and right margins cannot be made large enough to accommodate all axes decorations. 
    fig.tight_layout()

diversity/alpha/tests/test_base.py::BaseTests::test_pielou_e
  $PREFIX/lib/python3.9/site-packages/skbio/diversity/alpha/_base.py:793: RuntimeWarning: invalid value encountered in double_scalars
    return shannon(counts, base=np.e) / np.log(observed_otus(counts))

diversity/alpha/tests/test_base.py::BaseTests::test_pielou_e
  $PREFIX/lib/python3.9/site-packages/skbio/diversity/alpha/_base.py:869: RuntimeWarning: invalid value encountered in true_divide
    freqs = counts / counts.sum()

diversity/alpha/tests/test_base.py::BaseTests::test_pielou_e
  $PREFIX/lib/python3.9/site-packages/skbio/diversity/alpha/_base.py:793: RuntimeWarning: divide by zero encountered in log
    return shannon(counts, base=np.e) / np.log(observed_otus(counts))

diversity/beta/tests/test_unifrac.py::UnifracTests::test_invalid_input
diversity/tests/test_util.py::ValidationTests::test_validate_counts_matrix_unequal_lengths
  $PREFIX/lib/python3.9/site-packages/skbio/diversity/_util.py:52: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
    counts = np.asarray(counts)

diversity/tests/test_block.py: 3 warnings
diversity/tests/test_driver.py: 9 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/util/_decorator.py:254: DeprecationWarning: partial_beta_diversity is deprecated as of scikit-bio version 0.5.0, and will be removed in version 0.6.0. The return type is unstable. Developer caution is advised. The resulting DistanceMatrix object will include zeros when distance has not been calculated, and therefore can be misleading.
    warnings.warn('%s is deprecated as of scikit-bio version %s, and '

diversity/tests/test_driver.py: 7 warnings
stats/distance/tests/test_base.py: 4 warnings
util/tests/test_testing.py: 2 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/util/_testing.py:303: FutureWarning: The 'check_less_precise' keyword in testing.assert_*_equal is deprecated and will be removed in a future version. You can stop passing 'check_less_precise' to silence this warning.
    pdt.assert_series_equal(left, right,

diversity/tests/test_driver.py::BetaDiversityTests::test_qualitative_bug_issue_1549
  $PREFIX/lib/python3.9/site-packages/sklearn/metrics/pairwise.py:1870: DataConversionWarning: Data was converted to boolean for metric jaccard
    warnings.warn(msg, DataConversionWarning)

diversity/tests/test_util.py::ValidationTests::test_validate_counts_vector_invalid_input
  $PREFIX/lib/python3.9/site-packages/numpy/lib/type_check.py:300: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison
    return imag(x) == 0

io/format/fasta.py: 2 warnings
io/format/tests/test_fasta.py: 49 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/io/format/fasta.py:781: DeprecationWarning: `np.str` is a deprecated alias for the builtin `str`. To silence this warning, use `str` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.str_` here.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    qual_str = ' '.join(np.asarray(qual_scores, dtype=np.str))

io/format/newick.py: 5 warnings
tree/__init__.py: 2 warnings
tree/_nj.py: 3 warnings
tree/_tree.py: 23 warnings
tree/tests/test_tree.py: 18 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/tree/_tree.py:2189: DeprecationWarning: `np.int` is a deprecated alias for the builtin `int`. To silence this warning, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    mid = np.int(np.trunc((lo + hi) / 2))

io/format/tests/test_fasta.py: 52 warnings
io/format/tests/test_fastq.py: 75 warnings
sequence/_sequence.py: 4 warnings
sequence/tests/test_sequence.py: 5 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/sequence/_sequence.py:2105: DeprecationWarning: `np.bool` is a deprecated alias for the builtin `bool`. To silence this warning, use `bool` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.bool_` here.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    if self.positional_metadata[sliceable].dtype == np.bool:

io/format/tests/test_fasta.py: 52 warnings
io/format/tests/test_fastq.py: 75 warnings
sequence/_sequence.py: 4 warnings
sequence/tests/test_sequence.py: 3 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/sequence/_sequence.py:1308: DeprecationWarning: tostring() is deprecated. Use tobytes() instead.
    return str(outbytes.tostring().decode('ascii'))

io/format/tests/test_lsmat.py: 46 warnings
stats/distance/__init__.py: 3 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/io/format/lsmat.py:228: DeprecationWarning: `np.str` is a deprecated alias for the builtin `str`. To silence this warning, use `str` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.str_` here.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    fh.write(delimiter.join(np.asarray(vals, dtype=np.str)))

io/format/tests/test_ordination.py: 164 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/io/format/ordination.py:414: DeprecationWarning: `np.str` is a deprecated alias for the builtin `str`. To silence this warning, use `str` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.str_` here.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    formatted_vector = '\t'.join(np.asarray(vector, dtype=np.str))

sequence/_grammared_sequence.py::skbio.sequence._grammared_sequence.GrammaredSequence.has_nondegenerates
sequence/_grammared_sequence.py::skbio.sequence._grammared_sequence.GrammaredSequence.has_nondegenerates
sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_has_nondegenerates
sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_has_nondegenerates
sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_has_nondegenerates
sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_has_nondegenerates
sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_has_nondegenerates
sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_has_nondegenerates
  $PREFIX/lib/python3.9/site-packages/skbio/util/_decorator.py:254: DeprecationWarning: has_nondegenerates is deprecated as of scikit-bio version 0.5.0, and will be removed in version 0.6.0. Renamed to has_definites
    warnings.warn('%s is deprecated as of scikit-bio version %s, and '

sequence/_grammared_sequence.py::skbio.sequence._grammared_sequence.GrammaredSequence.nondegenerates
sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_nondegenerates
sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_nondegenerates
sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_nondegenerates
sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_nondegenerates
sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_nondegenerates
sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_nondegenerates
sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_nondegenerates
  $PREFIX/lib/python3.9/site-packages/skbio/util/_decorator.py:254: DeprecationWarning: nondegenerates is deprecated as of scikit-bio version 0.5.0, and will be removed in version 0.6.0. Renamed to definites
    warnings.warn('%s is deprecated as of scikit-bio version %s, and '

sequence/_sequence.py::skbio.sequence._sequence.Sequence.__getitem__
  <doctest skbio.sequence._sequence.Sequence.__getitem__[6]>:1: SyntaxWarning: "is" with a literal. Did you mean "=="?

sequence/tests/test_grammared_sequence.py: 19 warnings
sequence/tests/test_sequence.py: 2 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/sequence/_grammared_sequence.py:348: DeprecationWarning: tostring() is deprecated. Use tobytes() instead.
    [str(b.tostring().decode("ascii")) for b in bad] if

sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_nondegenerate_chars
sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_nondegenerate_chars
sequence/tests/test_grammared_sequence.py::TestGrammaredSequence::test_nondegenerate_chars
sequence/tests/test_nucleotide_sequences.py::TestNucleotideSequence::test_nondegenerate_chars
sequence/tests/test_nucleotide_sequences.py::TestNucleotideSequence::test_nondegenerate_chars
sequence/tests/test_nucleotide_sequences.py::TestNucleotideSequence::test_nondegenerate_chars
sequence/tests/test_nucleotide_sequences.py::TestNucleotideSequence::test_nondegenerate_chars
sequence/tests/test_protein.py::TestProtein::test_nondegenerate_chars
sequence/tests/test_protein.py::TestProtein::test_nondegenerate_chars
  $PREFIX/lib/python3.9/site-packages/skbio/util/_decorator.py:254: DeprecationWarning: nondegenerate_chars is deprecated as of scikit-bio version 0.5.0, and will be removed in version 0.6.0. Renamed to definite_chars
    warnings.warn('%s is deprecated as of scikit-bio version %s, and '

sequence/tests/test_sequence.py::TestSequence::test_frequencies_empty_sequence
  $PREFIX/lib/python3.9/site-packages/skbio/sequence/_sequence.py:1819: RuntimeWarning: invalid value encountered in true_divide
    obs_counts = obs_counts / len(self)

sequence/tests/test_sequence.py::TestSequence::test_init_invalid_sequence
  $PREFIX/lib/python3.9/site-packages/skbio/sequence/tests/test_sequence.py:461: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
    Sequence(np.array([1, {}, ()]))

sequence/tests/test_sequence.py: 20 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/sequence/_sequence.py:2124: DeprecationWarning: `np.bool` is a deprecated alias for the builtin `bool`. To silence this warning, use `bool` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.bool_` here.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    hasattr(s, 'dtype') and s.dtype != np.bool):

sequence/tests/test_sequence.py::TestSequence::test_munge_to_index_array_valid_iterable
  $PREFIX/lib/python3.9/site-packages/skbio/sequence/tests/test_sequence.py:2214: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray.
    for c in (lambda x: x, list, tuple, lambda x: np.array(tuple(x)),

stats/distance/_permdisp.py::skbio.stats.distance._permdisp.permdisp
  $PREFIX/lib/python3.9/site-packages/skbio/stats/ordination/_principal_coordinate_analysis.py:143: RuntimeWarning: The result contains negative eigenvalues. Please compare their magnitude with the magnitude of some of the largest positive eigenvalues. If the negative ones are smaller, it's probably safe to ignore them, but if they are large in magnitude, the results won't be useful. See the Notes section for more details. The smallest eigenvalue is -0.11904505999598304 and the largest is 0.6920448057121844.
    warn(

stats/distance/tests/test_base.py::DissimilarityMatrixTests::test_subset_to_dataframe
stats/distance/tests/test_base.py::DissimilarityMatrixTests::test_subset_to_dataframe
stats/distance/tests/test_base.py::DissimilarityMatrixTests::test_subset_to_dataframe
  $PREFIX/lib/python3.9/site-packages/skbio/stats/distance/_base.py:550: DeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.
    i = pd.Series(i, name='i')

stats/distance/tests/test_base.py::DissimilarityMatrixTests::test_subset_to_dataframe
stats/distance/tests/test_base.py::DissimilarityMatrixTests::test_subset_to_dataframe
stats/distance/tests/test_base.py::DissimilarityMatrixTests::test_subset_to_dataframe
  $PREFIX/lib/python3.9/site-packages/skbio/stats/distance/_base.py:551: DeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.
    j = pd.Series(j, name='j')

stats/distance/tests/test_base.py::DistanceMatrixTests::test_to_series_1x1
  $PREFIX/lib/python3.9/site-packages/skbio/stats/distance/tests/test_base.py:938: DeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.
    exp = pd.Series([], index=[])

stats/distance/tests/test_mantel.py::MantelTests::test_no_variation_pearson
  $PREFIX/lib/python3.9/site-packages/scipy/stats/stats.py:4023: PearsonRConstantInputWarning: An input array is constant; the correlation coefficient is not defined.
    warnings.warn(PearsonRConstantInputWarning())

stats/distance/tests/test_mantel.py::MantelTests::test_no_variation_spearman
  $PREFIX/lib/python3.9/site-packages/scipy/stats/stats.py:4484: SpearmanRConstantInputWarning: An input array is constant; the correlation coefficient is not defined.
    warnings.warn(SpearmanRConstantInputWarning())

stats/distance/tests/test_permdisp.py::testPERMDISP::test_centroids_eq_groups
stats/distance/tests/test_permdisp.py::testPERMDISP::test_no_permuations
  $PREFIX/lib/python3.9/site-packages/skbio/stats/ordination/_principal_coordinate_analysis.py:143: RuntimeWarning: The result contains negative eigenvalues. Please compare their magnitude with the magnitude of some of the largest positive eigenvalues. If the negative ones are smaller, it's probably safe to ignore them, but if they are large in magnitude, the results won't be useful. See the Notes section for more details. The smallest eigenvalue is -13.541846544269614 and the largest is 16.587201374785895.
    warn(

stats/distance/tests/test_permdisp.py::testPERMDISP::test_centroids_mixedgroups
stats/distance/tests/test_permdisp.py::testPERMDISP::test_centroids_uneq_groups
  $PREFIX/lib/python3.9/site-packages/skbio/stats/ordination/_principal_coordinate_analysis.py:143: RuntimeWarning: The result contains negative eigenvalues. Please compare their magnitude with the magnitude of some of the largest positive eigenvalues. If the negative ones are smaller, it's probably safe to ignore them, but if they are large in magnitude, the results won't be useful. See the Notes section for more details. The smallest eigenvalue is -15.629533932395201 and the largest is 20.903154277938906.
    warn(

stats/distance/tests/test_permdisp.py::testPERMDISP::test_centroids_null
stats/distance/tests/test_permdisp.py::testPERMDISP::test_not_distance_matrix
  $PREFIX/lib/python3.9/site-packages/skbio/stats/ordination/_principal_coordinate_analysis.py:188: RuntimeWarning: invalid value encountered in true_divide
    proportion_explained = eigvals / sum_eigenvalues

stats/distance/tests/test_permdisp.py::testPERMDISP::test_confirm_betadispr_results
  $PREFIX/lib/python3.9/site-packages/skbio/stats/ordination/_principal_coordinate_analysis.py:143: RuntimeWarning: The result contains negative eigenvalues. Please compare their magnitude with the magnitude of some of the largest positive eigenvalues. If the negative ones are smaller, it's probably safe to ignore them, but if they are large in magnitude, the results won't be useful. See the Notes section for more details. The smallest eigenvalue is -0.00775832514778066 and the largest is 2.7077929489469232.
    warn(

stats/ordination/__init__.py::skbio.stats.ordination
stats/ordination/tests/test_canonical_correspondence_analysis.py::TestCCAResults1::test_scaling1
stats/ordination/tests/test_canonical_correspondence_analysis.py::TestCCAResults1::test_scaling2
  $PREFIX/lib/python3.9/site-packages/skbio/stats/ordination/_canonical_correspondence_analysis.py:158: RuntimeWarning: invalid value encountered in reciprocal
    U_hat = Q_bar.dot(U) * s**-1

stats/ordination/__init__.py::skbio.stats.ordination
stats/ordination/tests/test_canonical_correspondence_analysis.py::TestCCAResults1::test_scaling1
stats/ordination/tests/test_canonical_correspondence_analysis.py::TestCCAResults1::test_scaling2
  $PREFIX/lib/python3.9/site-packages/skbio/stats/ordination/_canonical_correspondence_analysis.py:189: RuntimeWarning: invalid value encountered in reciprocal
    Z_scaling2 = Z_scaling1 * s**-1

stats/ordination/tests/test_principal_coordinate_analysis.py::TestPCoA::test_fsvd
stats/ordination/tests/test_principal_coordinate_analysis.py::TestPCoA::test_fsvd_inplace
stats/ordination/tests/test_principal_coordinate_analysis.py::TestPCoA::test_fsvd_inplace
stats/ordination/tests/test_util.py::TestUtils::test_center_distance_matrix_inplace
stats/ordination/tests/test_util.py::TestUtils::test_e_matrix_inplace
  $PREFIX/lib/python3.9/site-packages/skbio/stats/ordination/_utils.py:240: DeprecationWarning: `np.float` is a deprecated alias for the builtin `float`. To silence this warning, use `float` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.float64` here.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    distance_matrix = distance_matrix.astype(np.float)

stats/ordination/tests/test_principal_coordinate_analysis.py::TestPCoA::test_fsvd
stats/ordination/tests/test_principal_coordinate_analysis.py::TestPCoA::test_fsvd_inplace
stats/ordination/tests/test_principal_coordinate_analysis.py::TestPCoA::test_fsvd_inplace
stats/ordination/tests/test_util.py::TestUtils::test_center_distance_matrix_inplace
stats/ordination/tests/test_util.py::TestUtils::test_f_matrix_inplace
  $PREFIX/lib/python3.9/site-packages/skbio/stats/ordination/_utils.py:262: DeprecationWarning: `np.float` is a deprecated alias for the builtin `float`. To silence this warning, use `float` by itself. Doing this will not modify any behavior and is safe. If you specifically wanted the numpy scalar type, use `np.float64` here.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    e_matrix = e_matrix.astype(np.float)

stats/tests/test_composition.py: 37 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/stats/tests/test_composition.py:524: DeprecationWarning: `np.int` is a deprecated alias for the builtin `int`. To silence this warning, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    self.table2 = pd.DataFrame(self.table2.astype(np.int).T)

stats/tests/test_composition.py: 37 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/stats/tests/test_composition.py:557: DeprecationWarning: `np.int` is a deprecated alias for the builtin `int`. To silence this warning, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    self.table4 = pd.DataFrame(self.table4.astype(np.int).T)

stats/tests/test_composition.py: 37 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/stats/tests/test_composition.py:638: DeprecationWarning: `np.int` is a deprecated alias for the builtin `int`. To silence this warning, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    self.table9 = pd.DataFrame(self.table9.astype(np.int).T)

stats/tests/test_composition.py: 37 warnings
  $PREFIX/lib/python3.9/site-packages/skbio/stats/tests/test_composition.py:672: DeprecationWarning: `np.int` is a deprecated alias for the builtin `int`. To silence this warning, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
  Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
    self.table10 = pd.DataFrame(self.table10.astype(np.int).T)

stats/tests/test_composition.py::AncomTests::test_ancom_no_signal
  $PREFIX/lib/python3.9/site-packages/scipy/stats/stats.py:3650: F_onewayConstantInputWarning: Each of the input arrays is constant;the F statistic is not defined or infinite
    warnings.warn(F_onewayConstantInputWarning())

util/tests/test_decorator.py::TestDeprecated::test_function_output
  $PREFIX/lib/python3.9/site-packages/skbio/util/_decorator.py:254: DeprecationWarning: f is deprecated as of scikit-bio version 0.1.0, and will be removed in version 0.1.4. You should now use skbio.g().
    warnings.warn('%s is deprecated as of scikit-bio version %s, and '

util/tests/test_testing.py::TestAssertSeriesAlmostEqual::test_equal
util/tests/test_testing.py::TestAssertSeriesAlmostEqual::test_not_equal
  $PREFIX/lib/python3.9/site-packages/skbio/util/tests/test_testing.py:231: DeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.
    pd.Series(),

-- Docs: https://docs.pytest.org/en/stable/warnings.html
=========================== short test summary info ============================
FAILED alignment/tests/test_tabular_msa.py::TestLoc::test_multiindex_complicated_axis_empty_selection
FAILED stats/distance/_permdisp.py::skbio.stats.distance._permdisp.permdisp
FAILED stats/distance/tests/test_bioenv.py::BIOENVTests::test_bioenv_vegan_example
FAILED stats/distance/tests/test_permdisp.py::testPERMDISP::test_centroids_eq_groups
FAILED stats/distance/tests/test_permdisp.py::testPERMDISP::test_centroids_mixedgroups
FAILED stats/distance/tests/test_permdisp.py::testPERMDISP::test_centroids_null
FAILED stats/distance/tests/test_permdisp.py::testPERMDISP::test_centroids_uneq_groups
FAILED stats/tests/test_gradient.py::GradientTests::test_weight_by_vector - A...
==== 8 failed, 2536 passed, 30 skipped, 19763 warnings in 109.61s (0:01:49) ====

Leaving build/test directories:
  Work:
 /Users/runner/conda/conda-bld/work 
  Test:
 /Users/runner/conda/conda-bld/test_tmp 
Leaving build/test environments:
  Test:
source activate  /Users/runner/conda/conda-bld/_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_pla 
  Build:
source activate  /Users/runner/conda/conda-bld/_build_env 


