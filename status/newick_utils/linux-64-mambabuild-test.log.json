  Package          Version  Build          Channel                                   Size
───────────────────────────────────────────────────────────────────────────────────────────
  Install:
───────────────────────────────────────────────────────────────────────────────────────────

  + _libgcc_mutex      0.1  conda_forge    conda-forge/linux-64                    Cached
  + _openmp_mutex      4.5  1_gnu          conda-forge/linux-64                    Cached
  + icu               68.1  h58526e2_0     conda-forge/linux-64                    Cached
  + libgcc-ng       11.1.0  hc902ee8_8     conda-forge/linux-64                    Cached
  + libgomp         11.1.0  hc902ee8_8     conda-forge/linux-64                    Cached
  + libiconv          1.16  h516909a_0     conda-forge/linux-64                    Cached
  + libstdcxx-ng    11.1.0  h56837e0_8     conda-forge/linux-64                    Cached
  + libxml2         2.9.12  h72842e0_0     conda-forge/linux-64                    Cached
  + newick_utils       1.6  h779adbc_4     /home/vsts/conda/conda-bld/linux-64     124 KB
  + xz               5.2.5  h516909a_1     conda-forge/linux-64                    Cached
  + zlib            1.2.11  h516909a_1010  conda-forge/linux-64                    Cached

  Summary:

  Install: 11 packages

  Total download: 124 KB

───────────────────────────────────────────────────────────────────────────────────────────

Updating build index: /home/vsts/conda/conda-bld

TEST START: newick_utils-1.6-h779adbc_4.tar.bz2

## Package Plan ##

  environment location: /home/vsts/conda/conda-bld/newick_utils_1630748108202/_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold


The following NEW packages will be INSTALLED:

    _libgcc_mutex: 0.1-conda_forge      conda-forge
    _openmp_mutex: 4.5-1_gnu            conda-forge
    icu:           68.1-h58526e2_0      conda-forge
    libgcc-ng:     11.1.0-hc902ee8_8    conda-forge
    libgomp:       11.1.0-hc902ee8_8    conda-forge
    libiconv:      1.16-h516909a_0      conda-forge
    libstdcxx-ng:  11.1.0-h56837e0_8    conda-forge
    libxml2:       2.9.12-h72842e0_0    conda-forge
    newick_utils:  1.6-h779adbc_4       local      
    xz:            5.2.5-h516909a_1     conda-forge
    zlib:          1.2.11-h516909a_1010 conda-forge

Preparing transaction: ...working... done
Verifying transaction: ...working... done
Executing transaction: ...working... done
export PREFIX=/home/vsts/conda/conda-bld/newick_utils_1630748108202/_test_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold
export SRC_DIR=/home/vsts/conda/conda-bld/newick_utils_1630748108202/test_tmp
Extracts a subtree (clade) defined by labels.

Synopsis
--------

nw_clade [-chmrs] <target tree filename|-> <label> [label]+

Input
-----

The first argument is the name of a file containing one or more Newick
trees, or '-' (in which case the trees are read on stdin).

The next arguments are labels found in the tree (both leaf and internal
labels work). Any label not found in the tree will be ignored. There
must be at least one label. (See also option -r)

Output
------

Outputs the clade rooted at the last common ancestor of all labels passed
as arguments, as Newick.

Options
-------

    -c <levels (int)>: give context, i.e. start the subtree not at the last
        common ancestor of the labels, but 'level' nodes higher (limited
        by the tree's root, of course).
    -h: prints this message and exits
    -m: only prints the clade if it is monophyletic, in the sense that ONLY
        the labels passed as arguments are found in the clade.
        See also -s.
    -r <regexp>: clade is defined by labels that match the regexp (instead.
        of labels passed as arguments)
    -s: prints the siblings of the clade defined by the labels passed as
        arguments, in the order in which they appear in the Newick.
        If -m is also passed, only prints siblings if the labels passed
        as arguments form a monophyletic group.

Examples
--------

# clade defined by two leaves
$ nw_clade data/catarrhini Homo Hylobates

# clade defined by a leaf and a inner node (Hominini)
$ nw_clade data/catarrhini Hominini Hylobates

# clade is monophyletic
$ nw_clade -m data/catarrhini Homo Gorilla Pan

# clade is not monophyletic (Gorilla is missing)
$ nw_clade -m data/catarrhini Homo Pongo Pan

# clade defined by a regexp (all Poliovirus)
$ nw_clade -r data/HRV.nw '^POLIO.*'

# clade defined by Homo and Pan, plus 1 level of context
$ nw_clade -c 1 data/catarrhini Homo Pan
Simplifies a tree by collapsing certain nodes.

Synopsis
--------

nw_condense [-hm:u] <tree|->

Input
-----

Argument is either the name of a file that contains one or more trees, or '-',
in which case the trees are read on stdin.

Output
------

The tree(s) with pure clades collapsed. A pure clade is a clade in which
all leaves have the same label, and it is replaced by a leaf of the same
label: (A,(B,(B,B))); has a pure clade of B, and will be replaced by
(A,B);. The collapsed clade's support value (if any) is preserved, as is
its parent edge's length (if specified).
(see Options below for variants)

Options
-------

   -h: prints this message and exits
   -m <map file>: uses a group map. This is a text file that lists one
      label and one group name per line. For example a file with the
      following contents
            Homo Africa
            Hylobates Asia
            Gorilla Africa
            Pan Africa
            Pongo Asia
      maps the generic names of some apes to their continent of origin.
      That is, it defines the groups 'Asia' and 'Africa'. Labels and group
      names are white-separated and should not contain spaces.
        Clades consisting entirely of leaves belonging to a single group
      will be replaced by a single leaf whose label has the following
      structure: <group name>_<sample>_<size>, where <sample> is the label
      of one of the members of the clade, and <size> is the number of
      members of the clade.
        Applied to the Old world primates tree 'data/catarrhini', the above
      map would condense all African apes into a single leaf (since they
      form a clade) with label 'Africa_Homo_3'. It would not be able to
      condense further, however, because Pongo belong to group 'Asia'.
   -u: unicifies leaf labels by visiting the tree in Newick order and
      removing any leaf node whose label was already seen.

Example
-------

# produce a tree of families from a genus tree in which all genus names
# have been replaced by family names (see nw_rename) - look at
# data/falconiformes
$ nw_condense data/falc_families

# condense by geographic origin
$ nw_condense -m data/catarrhini_geog.map data/catarrhini
Prints distances between nodes, following tree branches, in various ways.

Synopsis
--------

nw_distance [-hmnst] <tree file|-> [label]*

Input
-----

First argument is the name of a file containing one or more trees, or '-'
(in which case trees are read from standard input). Any subsequent arguments
are node labels.

Output
------

Output is controlled by the mode and the selection. The mode specifies how
to compute distances, and the selection specifies which nodes to compute
distances for. There are four modes:
    o root mode (default): print distances from the tree's root to all
      nodes in the selection
    o last common ancestor mode: print distances from the LCA of all nodes
      in the selection to all nodes in the selection
    o parent mode: print distances from each node in the selection
      to its parent (0 for the root node)
    o matrix mode: print distances from each node in the selection
      to each node in the selection
Valid selections are:
    o all labeled leaves (default): selection is formed by all labeled
      leaf nodes, in the order in which they appear in the Newick string
      (= Newick order)
    o all labeled nodes: selection is formed by all labeled nodes, in
      Newick order (see Option -s)
    o all leaves: selection is formed by all leaves nodes, in
      Newick order (see Option -s)
    o all internal nodes: selection is formed by all internal nodes, in
      Newick order (see Option -s)
    o all nodes: selection is formed by all nodes, in Newick order
      (see Option -s)
    o command line arguments: labels are passed on the command line,
      and the selection is formed by the corresponding nodes, in the
      same order.

Options
-------

    -h: print this message and exit 
    -m <mode>: selects mode (see Output). Mode is determined by the first
        letter of the argument: 'r' for root mode (default), 'l' for LCA,
        'p' for parent, and 'm' for matrix. Thus, '-mm', '-m matrix',
        and '-m mat' all select matrix mode.
    -n: prints labels (or '' if empty) in addition to distances.
    -s <selection>, where selection is determined by the first letter of
        the argument: 'a' for all nodes, 'l' for labeled nodes,
        'i' for inner nodes, 'f' for leaves.
        E.g. '-s a' and '-s all' both select all nodes.
    -t: in matrix mode, print a triangular matrix. In other modes,
        print values on a line, separated by TABs.

Assumptions and Limitations
---------------------------

Labels passed as arguments are assumed to exist in the tree. Behaviour is
undefined if a label is not found.

Examples
--------

$ nw_distance data/catarrhini	# all (labeled) leaves, from root

# Pongo and Homo, from their LCA, with labels, single line
$ nw_distance -m lca -t -n data/catarrhini Homo Pongo 

# All labeled nodes, matrix form, with labels
$ nw_distance -mm -n -sl data/catarrhini

# All nodes, distance to parent
$ nw_distance -m p -s a data/catarrhini
Convert node ages to durations

Synopsis
--------

nw_duration [-h] <newick trees filename|->

Input
-----

Argument is the name of a file that contains Newick trees, or '-' (in
which case trees are read from standard input). The branch "lengths"
are interpreted as (absolute) dates, e.g. in Mya.

Output
------

Prints the input trees with branch lengths representing elapsed time.
This is handy if you have data about ages rather than durations, e.g.
you will typically know that two sister clades split 450 Mya, or that
some clade lasted from the early Devonian to the present. By using the
Newick format's 'length' slot to code ages, you can use this program
to generate a tree with correct branch lengths.

Options
-------

    -h: print this message and exit

Examples
--------

# File data/vertebrates.nw is age-encoded (every node's "length" is
# actually the age (in million years ago) when the branch split into
# the daughter branches). To get a usual, duration-encoded tree:

$ nw_duration data/vertebrates.nw

# This works well with options -Ir, -t and -u to nw_display:

$ nw_duration data/vertebrates.nw | nw_display -Ir -t -u 'million years ago' -
Performs actions on nodes that match some condition

Synopsis
--------

nw_ed [-hnor] <newick trees filename|-> <address> <action>

Input
-----

First argument is the name of a file that contains Newick trees, or '-' (in
which case trees are read from standard input).

Second argument is a node address, in the form of a logical expression (see
Addresses below).

Third argument is a code that specifies an action to perform on nodes
which match the address (see Actions).

Output
------

By default, prints the input tree, which may have been modified. However,
the 's' action (see Actions, below) causes matching subtrees to be
printed out.

This program is analogous to pattern-oriented, stream processing UNIX
utilities like sed(1) and awk(1), but instead of working on lines (like
sed) or records (like awk), nw_ed works on tree nodes.

The program traverses the tree in Newick order, evaluating the address
expression for each node in turn. If (and only if) the address matches, the
action is performed.

Addresses
---------

The address expression involves node properties such as depth, bootstrap
support, whether or not a node is a leaf, etc. These are represented by
single-letter codes, to make expressions short. For example:

				       i

matches internal nodes, while

				     b > 75

matches nodes whose label has a numerical value of 75 or more (if the label
is numeric). The usual logical and relational operators are available, so

				   i & b > 75

could be used to match internal nodes with a bootstrap support value
greater than 75.

The functions are:
    a numeric    number of ancestors of node	
    b numeric    node's support value (or zero)
    d numeric    node's depth (distance to root)
    c numeric    node's number of children
    D numeric    node's number of descendants
    i boolean    true iff node is strictly internal (i.e., not root!)
    l boolean    true iff node is a leaf
    r boolean    true iff node is the root

The operators are:
    ==  equality
    !=  inequality
    <   greater than
    >   lesser than
    >=  greater than or equal to
    <=  lesser than or equal to
    !   logical negation
    &   logical and
    |   logical or

The operator precedence is: negation, relationals, and, or; i.e. 

				 1 == d & !i | l

is equivalent to

			       ((1 == d) & (!i)) | l

Parentheses can be used for overriding precedence, or for clarity.

Actions
-------

Actions are performed on nodes that match the address. They are:
    s   (Subtree) print subtree rooted at matching node
    o   (splice Out) splice out node, and attach children to parent, 
	   preserving branch lengths. This is useful for "opening" poorly
          supported nodes.
    d   Delete node
    l   Print node's label


Options
-------

    -h: print this help text, and exit
    -n: do not print the (possibly modified) tree at the end of the run 
        (modeled after sed -n)
    -r: visit tree in preorder (starting at root, and visiting a node
        before any of its descendants). Default is post-order (ends at root
        and visits a node after all its descendats).
    -o: stop processing a clade after the first match - that is, if a node
        matches, its descendants are not processed.
        Note: this option will automatically set -r, as it makes no
        sense in post-order.

Bugs
----

Although there are no known bugs in this program, it is to be considered
more experimental than the others.

Examples
--------

# "open" all nodes with bootstrap support <= 10 (assuming support is coded
# in internal node labels)

$ nw_ed data/HRV.bs.nw 'i & b <= 10' o 

# "open" all nodes with bootstrap support < 750, then discard leaves that
# are directly attached to the ingroup's root. This effectively keeps only
# leaves that are part of well-supported clades.

$ nw_ed data/big.rn.nw 'i & b < 750' o | nw_ed - 'l & a == 2' d

# get all clades with at least one ancestor, 980 or better support. Do not
# print subtrees of matching clades, even if they match (option -o)

$ nw_ed data/big.rn.nw -n -o 'a >= 1 & b >= 980' s
Generates a random tree

Synopsis
--------

nw_gen [-dghlps]

Input
-----

None

Output
------

The generated tree. By default, this is a "time-limited" tree: branches
are "grown" using exponentially distributed lengths. If the length
exceeds the time limit, growth stops; otherwise the lineage splits in two,
and the process is repeated on the children.

Options
-------

    -d <float>: sets the maximum depth (time limit). Default: 3.0
       Only for time-limited trees.
    -g: generate a geometric tree instead of a time-limited one.
        Each node has a fixed probability of having 2 children.
    -h: print this message and exit
    -l <float>: sets the average branch length (default: 1.0)
       Only for time-limited trees.
    -p <float>: sets the probability of a node having (2) children.
       Only for geometric trees. WARNING: if > 0.5, the tree will
       probably grow 'forever'. On the other hand, low values will
       result in most trees having only a root, as the probability
       that the root has no children is 1-p, like for every other node.
    -s <int>: sets the pseudorandom number generator's seed
       (default: 0.1)

Examples
--------

# Generate a random time-limited tree

$ nw_gen
Indents the Newick, making structure more clear.

Synopsis
--------

nw_indent [-cht:] <newick trees filename|->

Input
-----

Argument is the name of a file that contains Newick trees, or '-' (in
which case trees are read from standard input).

Output
------

By default, prints the input tree, with each parenthesis and each leaf on a
line of its own, and indented a multiple of '  ' (two spaces) to reflect
structure. The default output is valid Newick.

This is useful for seeing the structure of larger trees, and also for
editing them. 

Indenting is purely lexical, therefore it tolerates syntax errors. A tree
that does not parse can be indented for examination, corrected, then
compacted (see Options).

Options
-------

    -c: compact - remove indentation 
    -h: print this message and exit
    -t <text>: use 'text' instead of the default '  '. WARNING: using
       anything else than whitespace is likely to result in output that
       is not valid Newick (which may or may not be a problem).
       Ignored with '-c'.

Examples
--------

# Indent
$ nw_indent data/catarrhini

# Indent, with visual guides for indentation (NOT valid Newick anymore)
$ nw_indent -t '|  ' data/catarrhini
Extracts the tree's labels

Synopsis
--------

nw_labels [-hILrt] <newick trees filename|->

Input
-----

Argument is the name of a file that contains Newick trees, or '-' (in
which case trees are read from standard input).

Output
------

By default, prints all labels that occur in the tree, in the same order as
in the Newick, one per line. Empty labels produce no output.

Options
-------

    -h: print this message and exit
    -I: don't print labels of inner nodes
    -L: don't print leaf labels
    -r: print only the root's label
    -t: TAB-separated - print on a single line, separated by tab stops.

Examples
--------

# just show labels
$ nw_labels data/catarrhini

# count leaves
$ nw_labels -I data/catarrhini | wc -l
Matches a tree to a pattern tree

Synopsis
--------
nw_match [-v] <target tree filename|-> <pattern tree>

Input
-----

The first argument is the name of the file containing the target tree (to
which support values are to be attributed), or '-' (in which case the tree
is read on stdin).

The second argument is a pattern tree

Output
------

Outputs the target tree if the pattern tree is a subgraph of it.

Options
-------

    -v: prints tree which do NOT match the pattern.

Limits & Assumptions
--------------------

Assumes that the labels are leaf labels, and that they are unique in
all trees (both target and pattern)

Example
-------

# Prints trees in data/vrt_gen.nw where Tamias is closer to Homo than it is
# to Vulpes:
$ nw_match data/vrt_gen.nw '((Tamias,Homo),Vulpes);'

# Prints trees in data/vrt_gen.nw where Tamias is NOT closer to Homo than it is
# to Vulpes:
$ nw_match -v data/vrt_gen.nw '((Tamias,Homo),Vulpes);'
Orders nodes according to various criteria, preserving topology

Synopsis
--------

nw_order [-c:hn] <newick trees filename|->

Input
-----

Argument is the name of a file that contains Newick trees, or '-' (in
which case trees are read from standard input).

Output
------

Orders the tree and prints it out on standard output. By default, the
ordering field is the node's label for leaves, or the first child's
order field for inner nodes. The tree's topology is not altered: the
biological information contained in the tree is left intact.

This is useful for comparing trees, because isomorphic trees will yield
different Newick representations if the nodes are ordered differently.

Options
-------

    -c <criterion>: specify order criterion. Possible criteria are 'a'
        (alphanumeric oder of labels), 'n' (number of descendants:
        nodes with fewer descendans appear first), 'd' (de-ladderize:
        alternately put nodes with fewer descendants before or after
        those with more)
        The default (i.e., if option -c is not given) is 'a'.
    -h: print this message and exit

Examples
--------

# De-ladderize tree
$ nw_order -c d ladder.nw

# These two trees look different...
$ diff -q data/falconiformes data/falconiformes_2 
Files data/falconiformes and data/falconiformes_2 differ

# but are they really?
$ nw_order data/falconiformes > f1
$ nw_order data/falconiformes_2 > f2

# No, they're in fact the same
$ diff -s f1 f2
Files f1 and f2 are identical
Removes nodes by label

Synopsis
--------

nw_prune [-f:hv] <newick trees filename|-> <label> [label+]

Input
-----

Argument is the name of a file that contains Newick trees, or '-' (in which
case trees are read from standard input).

Output
------

Removes all nodes whose labels are passed on the command line, and prints
out the modified tree. If removing a node causes its parent to have only
one child (as is always the case in strictly binary trees), the parent is
spliced out and the remaining child is attached to its grandparent,
preserving length.

Only labeled nodes are considered for pruning.

Options
-------

    -f: node labels are in a file whose name is the second argument,
        instead of being passed  on the command line.
        There should be one label per line, and no leading or trailing
        whitespace.
    -h: print this message and exit
    -v: reverse: prune nodes whose labels are NOT passed on the command
        line. Inner nodes are not pruned. This allows pruning of trees
        with support values, which syntactically are node labels, withouti
        inner nodes disappearing because their 'label' was not passed on
        the command line.

Assumptions and Limitations
---------------------------

Labels are assumed to be unique. 

Examples
--------

# Remove humans and gorilla
$ nw_prune data/catarrhini Homo Gorilla

# Remove humans, chimp, and gorilla
$ nw_prune data/catarrhini Homo Gorilla Pan

# the same, but using the clade's label
$ nw_prune data/catarrhini Homininae

# keep great apes and Colobines:
$ nw_prune -v data/catarrhini Gorilla Pan Homo Pongo Simias Colobus

# same, using clade labels:
$ nw_prune -v data/catarrhini Hominidae Colobinae
Renames nodes using a mapping

Synopsis
--------

nw_rename [-hl] <newick trees filename|-> <map filename>
or
nw_rename [-hl] <newick trees filename|-> <old-label> <new-label>

Input
-----

First argument is the name of a file that contains Newick trees, or '-' (in
which case trees are read from standard input).

In the first (two-argument) form, the second argument is the name of the
_map file_, which has one (old-name, new-name) pair per line, e.g:

cmp1	Compsognathus
trc	Triceratops
hnr
vlcr	Velociraptor

Old and new names should be separated by whitespace. If the new-name
is empty (such as for 'hnr' above), the label will be removed.

In the second (three-argument) form, the second argument is the old label
(i.e., the one to be replaced), and the third argument is the replacement.

In other words, the first form can replace more than one label, but
requires a map file, while the second form requires no file but is limited
to one label.

Output
------

Prints the tree, after replacing all old names by the specified new name.

Options
-------

    -h: print this message and exit
    -l: only replace leaf labels. This is useful if all labels are numeric,
        but inner labels represent bootstraps, and you don't want to
        accidentally modify bootstrap values.

Examples
--------

# Some tree-building programs don't allow labels longer than 10 characters
# or so. One way around this limitation is to relabel the sequences using
# numbers.  Tree data/HRV_numeric has numeric labels, because its outgroup,
# "Foot_and_Mouth" is longer than 10 characters. The number->label mapping
# was stored in file data/HRV.map. Now we can rename the whole tree:

$ nw_rename data/HRV_numeric data/HRV.map

# We can construct a tree of families from a genus tree and a genus->family
# map. File data/falconiformes is a tree of diurnal raptor genera, and
# data/falc_map maps the genera to families. To produce a family tree, we do: 

$ nw_rename data/falconiformes data/falc_map

# In fact, we could directly condense the tree, so that only one leaf per
# family is left:

$ nw_rename data/falconiformes data/falc_map | nw_condense -
(Re)roots a tree on a specified outgroup

Synopsis
--------

nw_reroot [-dhls] <newick trees filename|-> [label*]

Input
-----

First argument is the name of a file that contains Newick trees, or '-' (in
which case trees are read from standard input).

Further arguments are node labels. If there is at least one label, the tree
will be re-rooted on their LCAa. If there is no label, the tree is rerooted
on the longest branch. In this case the tree must be a phylogram.

Output
------

Re-roots the tree on the outgroup formed by the nodes whose labels are
passed as arguments (by finding their LCA and rooting on its parent edge).

Options
-------

    -d: deroot - splice out the LCA of the ingroup, attaching its children
        to the root. The ingroup is the root's child which has the more
        descendants. The root is expected to have two children. Other options
        have no effect.
    -h: print this message and exit
    -l: lax - if it is not possible to reroot on the outgroup, try the
        ingroup - that is, all nodes whose labels were NOT passed as
        arguments.  This can also fail, if both the outgroup and the
        ingroup have the tree's root as LCA. Note that to use this option
        you must make sure that you pass ALL outgroup labels, otherwise the
        ingroup will be wrong.
    -s: treat inner node labels as bipartition support values. Although they
        are attributed to nodes in Newick, these are actually properties of
        edges, and are treated differently from clade labels, which are
        really properties of nodes. The "Rerooting" section of the manual
        has more details.

Examples
--------

# This tree is rooted on humans, but the outgroup should be Cebus (New
# World monkey) - let's fix that: 

$ nw_reroot data/catarrhini_wrong Cebus

# We can reroot on more than one node:

$ nw_reroot data/catarrhini_wrong_3og Cebus Aotus 
Prints statistics about trees

Synopsis
--------

nw_stats [-hHf:] <newick trees filename|->

Input
-----

Argument is the name of a file that contains Newick trees, or '-' (in
which case trees are read from standard input).

Output
------

Prints information about the trees in the input. The info is printed:
Tree type, number of nodes, number of leaves, number of dichotomies,
number of leaf labels, number of inner labels. By default, the fields
are printed on a line, like this:
Type:	Phylogram
#nodes:	19
#leaves:	10
#dichotomies:	9
#leaf labels:	10
#inner labels:	6

Options
-------

    -h: print this message and exit
    -f [lc]: format in lines (l) or columns (c). Default is l.

Examples
--------

# default statistics:

$ nw_stats data/catarrhini.nw
Attributes bootstrap support values to a tree.

Synopsis
--------
nw_support [-ph] <target tree filename|-> <replicate trees filename>

Input
-----

The first argument is the name of the file containing the target tree (to which
support values are to be attributed), or '-' (in which case the tree is read on
stdin).

The second argument is the name of the file containing the replicates.

Output
------

Outputs the target tree, with a bipartition frequencies as inner node labels.

Options
-------

    -h: prints this message and exits
    -p: prints values as percentages (default: absolute frequencies)

Limits & Assumptions
--------------------

Assumes that the trees have the same number of leaves, and that all trees have
the same leaf labels. Behaviour is undefined if this is violated.

Example
-------

# Attributes bipartition counts to data/HRV.nw, based on 20 replicates
# stored in data/HRV_20reps.nw
$ nw_support data/HRV.nw data/HRV_20reps.nw
Discard some or all of a tree's non-structural information

Synopsis
--------

nw_topology [-bhIL] <newick trees filename|->

Input
-----

Argument is the name of a file that contains Newick trees, or '-' (in
which case trees are read from standard input).

Output
------

By default, prints the input trees without branch lengths, effectively
creating cladograms.

Options
-------

    -b: keep branch lengths
    -h: print this message and exit
    -I: discard inner node labels
    -L: discard leaf labels

Examples
--------

# Make a cladogram of Old-World monkeys and apes by discarding branch
# length data:

$ nw_topology data/catarrhini

# Make a purely structural tree (still valid Newick!)

$ nw_topology -IL data/catarrhini
Trims a tree in various ways.

Synopsis
--------

nw_trim [-ah] <newick trees filename|-> <maximum depth>

or
nw_trim [-h] <newick trees filename|->

Input
-----

Two-argument form:
The first argument is the name of a file that contains Newick trees, or '-'
(in which case trees are read from standard input). The second argument is
the maximum depth: nodes deeper than this will be trimmed.

One-argument form:
The argument is the name of the trees file, or '-' for standard input. The 
program trims the tree's root.

Output
------

A tree whose depth is at most the maximum depth (second argument).
Effectively, it is like cutting the tree at that value: nodes that are too
deep get trimmed, and internal nodes also lose their children.

Options
-------

    -a: the maximum depth is expressed in number of ancestors, not distance.
        Nodes are not shortened, but no node is retained that has more
        ancestors than the maximum.
    -h: print this message and exit

Examples
--------

# Cut tree at depth 20
$ nw_trim data/catarrhini 20

# Discard nodes with more than 3 ancestors
$ nw_trim -a data/catarrhini 3
Displays a tree as a graph, as text or SVG.

Synopsis
--------

nw_display [options] <tree filename|->

Input
-----

Argument is the name of the file containing one or more trees,
or '-' (in which case the tree is read on stdin).

Output
------

Outputs a graph representing the tree, either as text (default) or
as SVG (option -s). Underscores in labels are replaced with spaces.
Trees with no branch lengths are taken to be cladograms and are
drawn with leaves aligned. Otherwise, the tree is assumed to be a
phylogram: branch lengths are honored and a scale bar is drawn.

SVG graphics can be converted to other formats with converters
such as Inkscape (e.g. to PDF) or ImageMagick (e.g. to PNG or JPEG).
Inkscape is available from www.inkscape.org and ImageMagick from
www.imagemagick.org.

Options
-------

    -a <number>: rotate all labels by this amount (radians, default: 0)
       [only SVG radial]
    -A <number>: rotate left-side labels by this amount (radians,
       default: 0.0349 (=~ 2°)) [only SVG radial]
    -b <string>: CSS for branch length labels. [only SVG]
       Default: 'font-size:small;font-family:sans'.
       setting 'opacity:0' disables printing of branch lengths.
    -c <filename>: use specified file as CSS map [only SVG]. A CSS map
       is a text file which specifies a style (CSS) for a clade.
       Each line has the following structure:
       <CSS> <flag> <label>+
       <CSS> is a valid CSS style specification (no spaces allowed)
       e.g. 'font-size:small;font-family:italics;stroke:green'.
       <flag> is 'Individual', 'Clade', or 'Label' (case is not important,
       can be abbreviated down to 'I', 'C'i or 'L').
       If set to 'Clade', the style is applied to the clade defined by
       the labels. If 'Individual', the style is applied to each node
       individually.
       <label>+ is a nonempty, whitespace-separated list of Newick labels
       (spaces are allowed IFF the label is enclosed in ''). If a label
       matches more than one node, all matching nodes are used.
       Default: no CSS map, whole tree is black (unless specified otherwise
       via option -d).
       <CSS>, <flag>, and <labels>+ are separated by whitespace.
       The following specifies red stroke for a clade defined by A, B and C;
       2-pixel wide, blue stroke for individual nodes D, E, and F, and
       green italics for the labels 'A' and 'D'.
       stroke:red			Clade	A B C
       stroke:blue;stroke-width:2	I	D E F
       fill:green;font-style:italic	L	A D
       If no colormap is specified, the default is (but see option -d):
       stroke:black;fill:none;stroke-width:1;stroke-linecap:round
    -d <string>: CSS for 'plain' tree nodes (i.e., unless overridden by -c)
       [only SVG]
       Default: stroke:black;fill:none;stroke-width:1;stroke-linecap:round
    -e <raw|commas|slashes|vt100|utf8>: graph style (Text only). Values are:
       raw:		uses |, - , + and = .
       commas:		angles with , and'
       slashes:	angles with \ and /
       vt100:		use VT-100 box-drawing characters
       Only the first character is looked at, and case is not significant.
       The default is slashes. This can be overridden by setting environment
       variable NW_DISPLAY_TEXT_STYLE to one of the above values.
       NOTE: this is a rare case of a Newick Utils program not being
       backward-compatible. Even the 'raw' style does not exactly match the
       previous output (but this was buggy, the current output is different
       because it fixes problems).
    -h: prints this message and exits
    -i <string>: CSS for inner node labels. [only SVG]
       Default: 'font-size:small;font-family:sans'.
       setting 'visibility:hidden' disables printing of inner node labels.
    -I <char> sets the position of the inner node label. Valid options are
       'l' (near the leaves), 'm' (middle) or 'r' (near the root). Default
       is 'l'.
    -l <string>: CSS for leaf node labels. [only SVG]
       Default: 'font-size:medium;font-family:sans'.
       setting 'visibility:hidden' disables printing of leaf node labels.
       Note: if you change this, you will probably need to adjust the
       space allocated to leaf labels - see option -W.
    -n <number> add this number of pixels to the horizontal position of
       node labels. [SVG only]
    -o <filename>: use specified file as ornament map. Works like the CSS
       map (see option -c), except that it specifies arbitrary SVG snippets
       instead of CSS styles. For example, the following
       "<circle style='fill:red' r='5'>" Clade A B C
       will draw a red circle of radius 5 at the root of the clade defined
       by nodes A, B, and C. Keyword 'Individual' is also accepted and
       works like for CSS.
    -R <integer>: if <integer> is > 0, use that many pixels for the root
       if it has no length[only SVG]; if it is 0, suppress the root's edge
       length, if it has a length.
       The default is 10 pixels (SVG) or 1 character (text).
    -r: draw a radial tree (default: orthogonal) [only SVG]
    -s: output graph as SVG (default: ASCII graphics). All output is on
       stdout, so if there is more than one tree, stdout will be a
       concatenation of SVG documents. These can be split into individual
       files with the csplit(1) command:

       $ nw_display -s many_trees.nw > multiple_svg
       $ csplit -zs -f tree_ -b '%02d.svg' multiple_svg '/<?xml/' {*}

       will generate as many SVG files as there are Newick trees in
       many_trees.nw. The files will be named tree_01.svg, tree_02.svg, etc.
    -S: suppress scale bar (ignored for cladograms)
    -t: set the zero of the scale at the maximum depth instead of the root.
       This is useful when the branch lengths are in time units: zero marks
       the present, and the scale shows the age of the ancestral nodes.
    -u <string>: string is used as unit name for scale bar (ignored
       if no scale bar is drawn).
    -U <URL_filename>: use specified URL map [only SVG]. A URL map
       is a text file which specifies a URL for a label.
       Each line has the following structure:
       <label> <URL>
       Clicking on a label will follow the link (if any).
    -v <number>: number of pixels between leaves (default: 40) [only SVG
       orthogonal]
    -w <number>: set width or scale (exclusive or...)
       o If <number> is positive, then it fixes the width - the graph will
         be no wider than <number>, measured in columns for text and pixels
         for SVG. Defaults: 80 columns (text) or 300 px (SVG).
       o If <number> is _negative_, then its absolute value is used as a
         fixed scale, expressed in pixels/length units (SVG), or in
         columns/length units (text), in which length units are usually
         substitutions/site (but see option -u). If there are more than
         one tree, then this fixed scale is applied to all of them.
    -W <number>: use this as an estimate of the width of a leaf label
       character (in pixels) [only SVG]. This affects the space left for
       the tree nodes. Default: 5.0 You will probably need this if you
       change the leaf label font properties (option -l), especially size.
       You will probably need trial and error to find the right value.

LibXML
......

If LibXML is being used, the handling of ornaments (-o) is more elaborate.
See the tutorial, section 2.2 (displaying) for details.
This executable does NOT use LibXML2.

Examples
--------

# display tree as ASCII
$ nw_display data/catarrhini

# display tree as SVG, using a color map
$ nw_display -s -c data/color.map data/catarrhini

# ditto, convert to other graphics formats
$ nw_display -s -c data/color.map data/catarrhini > catarrhini.svg
$ convert catarrhini.svg catarrhini.png	# PNG, with ImageMagick
$ convert catarrhini.svg catarrhini.jpeg	# JPEG, with ImageMagick
$ inkscape -z -f catarrhini.svg -A catarrhini.pdf # PDF, with Inkscape

# the same; no branch lengths
$ nw_display -s -b 'visibility:hidden' -c data/color.map data/catarrhini

# radial tree, leaf labels in italics
$ nw_display -s -r -l 'font-style:italics' data/catarrhini

Resource usage statistics from testing newick_utils:
   Process count: 1
   CPU time: Sys=0:00:00.0, User=-
   Memory: 3.5M
   Disk usage: 16B
   Time elapsed: 0:00:02.1


TEST END: newick_utils-1.6-h779adbc_4.tar.bz2
--dirty flag and --keep-old-work not specified. Removing build/test folder after successful build/test.

